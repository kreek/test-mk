{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Background \u00b6 The government contracting model and the sheer size of the VA mean hundreds of teams have created or are creating APIs for the organization. As methodologies, architectures, and documentation standards vary from team to team, it's unsurprising that in the past the department provided fractured and inconsistent APIs to its consumers. Purpose \u00b6 The focus of the standards are the 'I' in API, the interface. It is not an application design guide or a programming manual. How teams develop an API behind that interface is up to them. The guide's main goal is to outline common interface and documentation standards for APIs deployed in Lighthouse. We do not intend for this guide to be read back-to-front. That said, the first section, General Guidelines , applies to all APIs on Lighthouse, and implementing teams should read it in its entirety. The remaining sections are more of a field manual or cookbook that is skimmed initially. Later, when presented with a problem whose solution is ambiguous, teams can reference this guide for Lighthouse's recommended solution or design pattern. Conventions \u00b6 Some items in the API standards are hard and fast rules, other are recommendations. RFC 2119 describes the keywords which signify the requirements in this guide. Those keywords appear in bold within their respective highlighted admonitions as below: Requirement Things you must and must not do as an absolute requirement of being on Lighthouse. Guidance API best practices that are recommended and those that are not recommended . Info Additional information and tips.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#background","text":"The government contracting model and the sheer size of the VA mean hundreds of teams have created or are creating APIs for the organization. As methodologies, architectures, and documentation standards vary from team to team, it's unsurprising that in the past the department provided fractured and inconsistent APIs to its consumers.","title":"Background"},{"location":"#purpose","text":"The focus of the standards are the 'I' in API, the interface. It is not an application design guide or a programming manual. How teams develop an API behind that interface is up to them. The guide's main goal is to outline common interface and documentation standards for APIs deployed in Lighthouse. We do not intend for this guide to be read back-to-front. That said, the first section, General Guidelines , applies to all APIs on Lighthouse, and implementing teams should read it in its entirety. The remaining sections are more of a field manual or cookbook that is skimmed initially. Later, when presented with a problem whose solution is ambiguous, teams can reference this guide for Lighthouse's recommended solution or design pattern.","title":"Purpose"},{"location":"#conventions","text":"Some items in the API standards are hard and fast rules, other are recommendations. RFC 2119 describes the keywords which signify the requirements in this guide. Those keywords appear in bold within their respective highlighted admonitions as below: Requirement Things you must and must not do as an absolute requirement of being on Lighthouse. Guidance API best practices that are recommended and those that are not recommended . Info Additional information and tips.","title":"Conventions"},{"location":"general-guidelines/","text":"General Guidelines \u00b6 This section outlines the general guidelines for the architecture and documentation standards that all APIs on Lighthouse follow. We recommend established industry API standards. While developing APIs for the Department of Veterans Affairs (VA) and the government presents unique challenges, providers can leverage API guidelines honed in the open source community and the private sector. Not all consumers will be familiar with the VA API landscape. Following industry standards and best practices will ensure that Lighthouse APIs share a common interface and behave similarly to best APIs outside of VA. Building upon these standards reduces the documentation needed to get started and lets developers access the more in-depth, industry-standard documentation elsewhere if desired. In this section: API-first : Creating API contract before beginning development. Documentation : Documenting the API in a format both humans and computers understand. Architecture : REST as the architectural style we prescribe for distributed systems. Data interchange : JSON as the recommended format for passing data between those systems.","title":"General Guidelines"},{"location":"general-guidelines/#general-guidelines","text":"This section outlines the general guidelines for the architecture and documentation standards that all APIs on Lighthouse follow. We recommend established industry API standards. While developing APIs for the Department of Veterans Affairs (VA) and the government presents unique challenges, providers can leverage API guidelines honed in the open source community and the private sector. Not all consumers will be familiar with the VA API landscape. Following industry standards and best practices will ensure that Lighthouse APIs share a common interface and behave similarly to best APIs outside of VA. Building upon these standards reduces the documentation needed to get started and lets developers access the more in-depth, industry-standard documentation elsewhere if desired. In this section: API-first : Creating API contract before beginning development. Documentation : Documenting the API in a format both humans and computers understand. Architecture : REST as the architectural style we prescribe for distributed systems. Data interchange : JSON as the recommended format for passing data between those systems.","title":"General Guidelines"},{"location":"general-guidelines/api-first/","text":"API-first \u00b6 Guidance Providers should design their API before beginning implementation. An API-first approach means that a team should design and iterate upon the API before beginning development and treat the API as a first-class product rather than just another component of the system. This approach: - Makes implementation go more smoothly - Reduces implementation time - Increases the changes implementation is correct by centering the API around the consumer - Does not lessen the importance of implementation The resulting speed and accuracy benefits not only the providing team, but the consuming teams by allowing them to begin work earlier, and in parallel, when they have a design to build against. Mock response data can act as a placeholder in specs and tests while the provider fleshes out the implementation details. Finally, developers often neglect documentation in software projects. A fortunate side effect of the API-first approach is that your design is also documentation. Documentation will be complete before you start implementation and will require only minor tweaks along the way to reflect your API when development is complete.","title":"API First"},{"location":"general-guidelines/api-first/#api-first","text":"Guidance Providers should design their API before beginning implementation. An API-first approach means that a team should design and iterate upon the API before beginning development and treat the API as a first-class product rather than just another component of the system. This approach: - Makes implementation go more smoothly - Reduces implementation time - Increases the changes implementation is correct by centering the API around the consumer - Does not lessen the importance of implementation The resulting speed and accuracy benefits not only the providing team, but the consuming teams by allowing them to begin work earlier, and in parallel, when they have a design to build against. Mock response data can act as a placeholder in specs and tests while the provider fleshes out the implementation details. Finally, developers often neglect documentation in software projects. A fortunate side effect of the API-first approach is that your design is also documentation. Documentation will be complete before you start implementation and will require only minor tweaks along the way to reflect your API when development is complete.","title":"API-first"},{"location":"general-guidelines/architecture/","text":"Architecture \u00b6 Guidance Lighthouse APIs should use a RESTful architecture. SOAP, RPC, or GraphQL, are not recommended as they are unsupported by our tooling. REST \u00b6 REST is the most widely-adopted architectural style for distributed systems. Much of its popularity comes from its consistency and the fact that its underlying interface is HTTP, the foundation of data communication for the web which nearly all clients and servers understand. REST provides a second layer of uniformity by placing 'Resources' and the manipulation of their state via identifiers at the center of client/server interactions. This reduces friction for those developing and implementing the API. Endpoint paths for resources are one example of REST convention that delineates a solution that would be ambiguous with other architectures. So, for example: What's the path for a list of resources? REST prescribes using the HTTP GET method and the plural name of the resource: request 1 GET ../rx/v0/prescriptions What if we then want to update a specific resource from that list? Use the HTTP PUT method and append its identifier: request 1 PUT ../rx/v0/prescriptions/e526c85d-29fc-432c-a16d-df5cdfce2a62 Constraints of a RESTful system \u00b6 Roy Fielding designed REST to facilitate building distributed systems that are efficient, scalable, and reliable. His PhD dissertation \"Architectural Styles and the Design of Network-based Software Architectures\" explains this in great detail. This guide does not reproduce that dissertation here, however an API is 'RESTful' if it meets the following constraints 1 : Client/server separation : There must be a clear separation of concerns when components like a web or mobile application and its back-end API server work together and communicate. Statelessness : A request contains all the information needed for the server to execute it. The server does not store client context in a session between requests. Cacheability : A response to a request must disclose if the client can store and reuse it and for how long. Layered system : The client is only aware of the details of the server. It does not know or need to know about systems two or more layers down supporting the server. Uniform interface : Resources and the manipulation of their state via standard HTTP methods guide the development of a consistent interface. An optional sixth constraint, 'Code on demand', in which the server transfers executable code to the client must not be implemented in Lighthouse APIs due to security concerns. \u21a9","title":"Architecture"},{"location":"general-guidelines/architecture/#architecture","text":"Guidance Lighthouse APIs should use a RESTful architecture. SOAP, RPC, or GraphQL, are not recommended as they are unsupported by our tooling.","title":"Architecture"},{"location":"general-guidelines/architecture/#rest","text":"REST is the most widely-adopted architectural style for distributed systems. Much of its popularity comes from its consistency and the fact that its underlying interface is HTTP, the foundation of data communication for the web which nearly all clients and servers understand. REST provides a second layer of uniformity by placing 'Resources' and the manipulation of their state via identifiers at the center of client/server interactions. This reduces friction for those developing and implementing the API. Endpoint paths for resources are one example of REST convention that delineates a solution that would be ambiguous with other architectures. So, for example: What's the path for a list of resources? REST prescribes using the HTTP GET method and the plural name of the resource: request 1 GET ../rx/v0/prescriptions What if we then want to update a specific resource from that list? Use the HTTP PUT method and append its identifier: request 1 PUT ../rx/v0/prescriptions/e526c85d-29fc-432c-a16d-df5cdfce2a62","title":"REST"},{"location":"general-guidelines/architecture/#constraints-of-a-restful-system","text":"Roy Fielding designed REST to facilitate building distributed systems that are efficient, scalable, and reliable. His PhD dissertation \"Architectural Styles and the Design of Network-based Software Architectures\" explains this in great detail. This guide does not reproduce that dissertation here, however an API is 'RESTful' if it meets the following constraints 1 : Client/server separation : There must be a clear separation of concerns when components like a web or mobile application and its back-end API server work together and communicate. Statelessness : A request contains all the information needed for the server to execute it. The server does not store client context in a session between requests. Cacheability : A response to a request must disclose if the client can store and reuse it and for how long. Layered system : The client is only aware of the details of the server. It does not know or need to know about systems two or more layers down supporting the server. Uniform interface : Resources and the manipulation of their state via standard HTTP methods guide the development of a consistent interface. An optional sixth constraint, 'Code on demand', in which the server transfers executable code to the client must not be implemented in Lighthouse APIs due to security concerns. \u21a9","title":"Constraints of a RESTful system"},{"location":"general-guidelines/data-interchange/","text":"Data Interchange \u00b6 Guidance Lighthouse APIs should interchange data serialized as JSON. APIs may return binary data for files (images, PDFs, etc). XML may be used when interfacing with legacy systems. Binary data formats (ProtoBufs, Avro, Thrift) are not recommended for public-facing APIs. JSON \u00b6 Requirement JSON must conform to the JSON Data Interchange Format described in RFC 7159 Request and response bodies must be valid against JSON Schema Draft v4 or higher. As REST is the dominant web API architecture, JSON is the dominant web data-interchange format. REST APIs revolve around resources. They are better described using JSON's structured data than a markup language that structures information, such as XML. JSON's advantages over XML include: - Its shared data model, obviously with JavaScript, but also with any language that implements booleans, numbers, strings, arrays, and objects (or objects like data structures, i.e. dictionaries or hashes). - It produces a smaller payload than XML. - In most languages, it compresses (gzips) faster. - is more human-readable than XML. Information models \u00b6 Guidance We recommend that APIs default to using JSON:API as an information model. Industry-specific standards, such as FHIR for health data may be used. Information/hypermedia models such as OData, HAL, JSON-LD, and SIREN are not recommended . An information model specifies a set of shared conventions for JSON data to ensure formatting is consistent across a set of APIs. For example, even if APIs agree on using JSON, they could each still disagree on how they format and identify resources. Additionally, there are varied ways one could render related resources, metadata, errors, and design patterns such as pagination and filtering. With an information model in place, figuring out how to render errors or paginate a list is a matter of looking up the recommendation from the model\u2019s specification.","title":"Data Interchange"},{"location":"general-guidelines/data-interchange/#data-interchange","text":"Guidance Lighthouse APIs should interchange data serialized as JSON. APIs may return binary data for files (images, PDFs, etc). XML may be used when interfacing with legacy systems. Binary data formats (ProtoBufs, Avro, Thrift) are not recommended for public-facing APIs.","title":"Data Interchange"},{"location":"general-guidelines/data-interchange/#json","text":"Requirement JSON must conform to the JSON Data Interchange Format described in RFC 7159 Request and response bodies must be valid against JSON Schema Draft v4 or higher. As REST is the dominant web API architecture, JSON is the dominant web data-interchange format. REST APIs revolve around resources. They are better described using JSON's structured data than a markup language that structures information, such as XML. JSON's advantages over XML include: - Its shared data model, obviously with JavaScript, but also with any language that implements booleans, numbers, strings, arrays, and objects (or objects like data structures, i.e. dictionaries or hashes). - It produces a smaller payload than XML. - In most languages, it compresses (gzips) faster. - is more human-readable than XML.","title":"JSON"},{"location":"general-guidelines/data-interchange/#information-models","text":"Guidance We recommend that APIs default to using JSON:API as an information model. Industry-specific standards, such as FHIR for health data may be used. Information/hypermedia models such as OData, HAL, JSON-LD, and SIREN are not recommended . An information model specifies a set of shared conventions for JSON data to ensure formatting is consistent across a set of APIs. For example, even if APIs agree on using JSON, they could each still disagree on how they format and identify resources. Additionally, there are varied ways one could render related resources, metadata, errors, and design patterns such as pagination and filtering. With an information model in place, figuring out how to render errors or paginate a list is a matter of looking up the recommendation from the model\u2019s specification.","title":"Information models"},{"location":"general-guidelines/documentation/","text":"Documentation \u00b6 Requirement Providers must document their API using the OpenAPI Specification version 3.0.x OpenAPI docs must be valid YAML or JSON so they are machine-readable. OpenAPI Specification \u00b6 OpenAPI Specification (OAS) is the predominant API documentation standard in the industry. All providers on Lighthouse must document their APIs using the OpenAPI Specification as a requirement of onboarding. Version 3.0.3 of the OpenAPI Specification can be found here . Documentation for humans and computers \u00b6 An OAS serves as documentation for human consumers to read when evaluating or using an API and as a machine-readable input for Lighthouse tooling that verifies consistency between the API\u2019s specification and its behavior. OAS docs must be valid in Swagger Editor . Lighthouse OAS Subjective Rules \u00b6 OAS docs also undergo a subjective review for items we can't automate or that are open to interpretation. Below is a list of the subjective rules found within this guide: Security Endpoints that return PII or PHI must use OAuth. Endpoints secured with OAuth must list the required scopes in the security section of each endpoint. Headers APIs must not use headers to communicate business logic or service logic (such as paging response info or PII query parameters). HTTP headers should only be used for the purpose of handling cross-cutting concerns such as authorization. Resource Operations GET Endpoints must use the POST method when creating resources without a consumer-supplied ID. GET operations should return a 201 with the created resource reflected in the response body. POST should not be idempotent; meaning, if the request is sent again, a second resource should be created. PUT should be idempotent, meaning that calling it several times should return the same result. Operations should return the created resource inside a data object. Operations should return any errors inside an errors object. Providers should show that a custom operation was intentional by ending the path with a verb. Naming & Formatting Fields should use camelCase. Acronyms should be camelCase rather than uppercase. Providers should avoid abbreviations. Booleans should be prefixed with an auxiliary verb (such as is, has, or can). Example OAS Document \u00b6 Below is an example OAS doc for a fictitious 'Rx' API on Lighthouse. Click on the circular buttons labeled with a '+' to view code annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 openapi : 3.0.0 # (1) info : # (15) title : Rx description : An example 'Rx' API that follows the [Lighthouse API Standards](https://department-of-veterans-affairs.github.io/lighthouse-api-standards). contact : name : VA.gov version : 1.0.0 servers : # (3) - url : 'https://sandbox-api.va.gov/services/rx/{version}' description : Lighthouse API sandbox environment variables : version : default : v1 - url : 'https://api.va.gov/services/rx/{version}' description : Lighthouse API production environment variables : version : default : v1 paths : /pharmacies : get : tags : - pharmacy summary : Returns a list of facilities with pharmacies. # (16) description : Returns a paginated list of all VA facilities that provide pharmacological services. operationId : getPharmacies responses : '200' : description : The veteran's prescriptions were successfully found and returned as an array. content : application/json : schema : # (4) $ref : '#/components/schemas/PharmacyList' '500' : # (5) $ref : '#/components/responses/ErrorInternalServerError' '502' : # (6) $ref : '#/components/responses/ErrorInternalServerError' '503' : # (7) $ref : '#/components/responses/ErrorServiceUnavailable' security : # (8) - {} /prescriptions : get : tags : - prescription summary : Returns a list of a veteran's prescriptions description : Given a veteran's ICN, the endpoint returns a list of their prescriptions. operationId : getPrescriptions parameters : # (17) - in : query name : icn description : MPI ICN required : true schema : maxLength : 17 minLength : 17 pattern : '^\\d{10}V\\d{6}$' type : string example : 1012667145V762142 responses : '200' : description : The veteran's prescriptions were successfully found and returned as an array. content : application/json : schema : $ref : '#/components/schemas/PrescriptionList' '401' : # (18) $ref : '#/components/responses/ErrorUnauthorized' '403' : $ref : '#/components/responses/ErrorForbidden' '404' : $ref : '#/components/responses/ErrorNotFound' '422' : description : Unprocessable Entity content : application/json : schema : type : object example : errors : - status : 422 title : Invalid ICN detail : 'ICN must match \\\"^\\\\d{10}V\\\\d{6}$\\\", size must be exactly 17.' '500' : $ref : '#/components/responses/ErrorInternalServerError' '502' : $ref : '#/components/responses/ErrorBadGateway' '503' : $ref : '#/components/responses/ErrorServiceUnavailable' security : - bearerToken : # (12) - prescription.read # (19) components : # (9) securitySchemes : bearerToken : type : http scheme : bearer production : type : oauth2 description : This API uses OAuth 2 with the authorization code grant flow. flows : authorizationCode : authorizationUrl : https://api.va.gov/oauth2/authorization tokenUrl : https://api.va.gov/oauth2/token scopes : prescription.read : Retrieve prescription data sandbox : type : oauth2 description : This API uses OAuth 2 with the authorization code grant flow. flows : authorizationCode : authorizationUrl : https://sandbox-api.va.gov/oauth2/authorization tokenUrl : https://sandbox-api.va.gov/oauth2/token scopes : prescription.read : Retrieve prescription data responses : # (10) ErrorUnauthorized : description : Unauthorized content : application/json : schema : type : object example : errors : - status : 401 title : Unauthorized detail : Invalid credentials. The access token has expired. ErrorForbidden : description : Forbidden content : application/json : schema : type : object example : errors : - status : 403 title : Forbidden detail : You do not have access to the requested resource. ErrorNotFound : description : Not Found content : application/json : schema : type : object example : errors : - status : 404 title : Not Found detail : The requested resource could not be found. ErrorInternalServerError : description : Internal Server Error content : application/json : schema : type : object example : errors : - status : 500 title : Internal Server Error detail : An internal API error occurred. ErrorBadGateway : description : Bad Gateway content : application/json : schema : type : object example : errors : - status : 502 title : Bad Gateway detail : An upstream service the API depends on returned an error. ErrorServiceUnavailable : description : Service Unavailable content : application/json : schema : type : object example : errors : - status : 503 detail : An upstream service is unavailable. schemas : PharmacyList : type : object required : - data properties : data : type : array items : $ref : \"#/components/schemas/Pharmacy\" # (11) Pharmacy : type : object required : - type - id - attributes properties : type : type : string example : Pharmacy id : type : string example : 6e976911-2707-4018-a6db-0d1342326379 attributes : type : object required : - id - name - city - state - cerner - clinics properties : id : type : string example : \"358\" name : type : string example : \"Cheyenne VA Medical Center Pharmacy\" city : type : string example : \"Cheyenne\" state : $ref : '#/components/schemas/State' PrescriptionList : type : object required : - data properties : data : type : array items : $ref : \"#/components/schemas/Prescription\" Prescription : type : object required : - type - id - attributes properties : type : type : string example : Prescription id : type : string example : db8a52f0-b3d2-4cc9-bcab-7053d88737d5 attributes : type : object required : - productNumber - referenceDrug - brandName - activeIngredients - referenceStandard - dosageForm - route properties : productNumber : type : string example : '001' referenceDrug : type : boolean example : false brandName : type : string example : 'FAMOTIDINE PRESERVATIVE FREE' activeIngredients : type : object required : - name - strength properties : name : type : string example : \"FAMOTIDINE\" strength : type : string example : \"10MG/ML\" referenceStandard : type : boolean example : false dosageForm : type : string enum : [ \"INJECTABLE\" , \"TABLET\" ] # (13) example : \"TABLET\" route : type : string enum : [ \"INJECTION\" , \"ORAL\" ] example : \"ORAL\" State : # (14) type : string enum : - AK - AL - AR - AZ - CA - CO - CT - DE - FL - GA - HI - IA - ID - IL - IN - KS - KY - LA - MA - MD - ME - MI - MN - MO - MS - MT - NC - ND - NE - NH - NJ - NM - NV - NY - OH - OK - OR - PA - RI - SC - SD - TN - TX - UT - VA - VT - WA - WI - WV - WY example : \"WY\" OpenAPI Spec 3.0.x is the required version. Version 3.1 can not be used yet as SwaggerUI does not support it at this time. If you use JSON Schema to define your models, you can set the dialect globally through the jsonSchemaDialect property. The servers section should reflect your API's future external public-facing location when hosted on Lighthouse. All endpoints should then be relative to those base URLs. You can copy the example definition starting on this line (#9) to use in your OAS doc; remember to replace rx with your namespace. Using $ref properties (references) to link to response body schema definitions helps keep your endpoint definitions short. Errors happen. We require that all APIs let consumers know the error schema your API will return should your API encounter an unexpected error. Many VA APIs rely on one or more upstream services for their data. If your API could throw a 500 if an upstream service returns an error, consider returning a 502 error instead, so you and the consumer know a dependency rather than the API is causing the issue. If your API could throw a 500 if an upstream service is down, consider returning a 503 error instead, so you and the consumer know a dependency rather than the API is causing the issue. All endpoints must have a security property. In this example, the endpoint does not require authentication. However, the security tag is still included but it contains an empty object. This lets us know security was left out on purpose. Often, multiple API operations have some common parameters or return the same response structure. To avoid code duplication, you can place the common definitions in the global components section and reference them using $ref . Responses, and specifically errors, are likely to be the same for all endpoints. Defining them within the components/responses can help keep down the size of your path definitions. $refs can have $refs . Think of schemas like their database counterparts. Each model and its relations should be a distinct schema. This endpoint returns a veteran's prescription history, which qualifies as Personal Health Information (PHI). All endpoints that return PII or PHI must use OAuth. Enums should be considered constants. As in 'C' style languages, they should be UPPER_CASE with underscores for spaces. Components don't have to be resources. Any data that appears in multiple locations, such as a list of states, can be a component. Info tags must include a title and a description . Path methods must contain a shorter summary and a longer description that explains the purpose and function of each operation. Requests should use URL or body parameters rather than headers to pass along requisite data unique to that endpoint. Protected endpoints must define 401 Unauthorized and 403 Forbidden responses. The prescription.read scope is required for this endpoint so it is listed in the security section.","title":"Documentation"},{"location":"general-guidelines/documentation/#documentation","text":"Requirement Providers must document their API using the OpenAPI Specification version 3.0.x OpenAPI docs must be valid YAML or JSON so they are machine-readable.","title":"Documentation"},{"location":"general-guidelines/documentation/#openapi-specification","text":"OpenAPI Specification (OAS) is the predominant API documentation standard in the industry. All providers on Lighthouse must document their APIs using the OpenAPI Specification as a requirement of onboarding. Version 3.0.3 of the OpenAPI Specification can be found here .","title":"OpenAPI Specification"},{"location":"general-guidelines/documentation/#documentation-for-humans-and-computers","text":"An OAS serves as documentation for human consumers to read when evaluating or using an API and as a machine-readable input for Lighthouse tooling that verifies consistency between the API\u2019s specification and its behavior. OAS docs must be valid in Swagger Editor .","title":"Documentation for humans and computers"},{"location":"general-guidelines/documentation/#lighthouse-oas-subjective-rules","text":"OAS docs also undergo a subjective review for items we can't automate or that are open to interpretation. Below is a list of the subjective rules found within this guide: Security Endpoints that return PII or PHI must use OAuth. Endpoints secured with OAuth must list the required scopes in the security section of each endpoint. Headers APIs must not use headers to communicate business logic or service logic (such as paging response info or PII query parameters). HTTP headers should only be used for the purpose of handling cross-cutting concerns such as authorization. Resource Operations GET Endpoints must use the POST method when creating resources without a consumer-supplied ID. GET operations should return a 201 with the created resource reflected in the response body. POST should not be idempotent; meaning, if the request is sent again, a second resource should be created. PUT should be idempotent, meaning that calling it several times should return the same result. Operations should return the created resource inside a data object. Operations should return any errors inside an errors object. Providers should show that a custom operation was intentional by ending the path with a verb. Naming & Formatting Fields should use camelCase. Acronyms should be camelCase rather than uppercase. Providers should avoid abbreviations. Booleans should be prefixed with an auxiliary verb (such as is, has, or can).","title":"Lighthouse OAS Subjective Rules"},{"location":"general-guidelines/documentation/#example-oas-document","text":"Below is an example OAS doc for a fictitious 'Rx' API on Lighthouse. Click on the circular buttons labeled with a '+' to view code annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 openapi : 3.0.0 # (1) info : # (15) title : Rx description : An example 'Rx' API that follows the [Lighthouse API Standards](https://department-of-veterans-affairs.github.io/lighthouse-api-standards). contact : name : VA.gov version : 1.0.0 servers : # (3) - url : 'https://sandbox-api.va.gov/services/rx/{version}' description : Lighthouse API sandbox environment variables : version : default : v1 - url : 'https://api.va.gov/services/rx/{version}' description : Lighthouse API production environment variables : version : default : v1 paths : /pharmacies : get : tags : - pharmacy summary : Returns a list of facilities with pharmacies. # (16) description : Returns a paginated list of all VA facilities that provide pharmacological services. operationId : getPharmacies responses : '200' : description : The veteran's prescriptions were successfully found and returned as an array. content : application/json : schema : # (4) $ref : '#/components/schemas/PharmacyList' '500' : # (5) $ref : '#/components/responses/ErrorInternalServerError' '502' : # (6) $ref : '#/components/responses/ErrorInternalServerError' '503' : # (7) $ref : '#/components/responses/ErrorServiceUnavailable' security : # (8) - {} /prescriptions : get : tags : - prescription summary : Returns a list of a veteran's prescriptions description : Given a veteran's ICN, the endpoint returns a list of their prescriptions. operationId : getPrescriptions parameters : # (17) - in : query name : icn description : MPI ICN required : true schema : maxLength : 17 minLength : 17 pattern : '^\\d{10}V\\d{6}$' type : string example : 1012667145V762142 responses : '200' : description : The veteran's prescriptions were successfully found and returned as an array. content : application/json : schema : $ref : '#/components/schemas/PrescriptionList' '401' : # (18) $ref : '#/components/responses/ErrorUnauthorized' '403' : $ref : '#/components/responses/ErrorForbidden' '404' : $ref : '#/components/responses/ErrorNotFound' '422' : description : Unprocessable Entity content : application/json : schema : type : object example : errors : - status : 422 title : Invalid ICN detail : 'ICN must match \\\"^\\\\d{10}V\\\\d{6}$\\\", size must be exactly 17.' '500' : $ref : '#/components/responses/ErrorInternalServerError' '502' : $ref : '#/components/responses/ErrorBadGateway' '503' : $ref : '#/components/responses/ErrorServiceUnavailable' security : - bearerToken : # (12) - prescription.read # (19) components : # (9) securitySchemes : bearerToken : type : http scheme : bearer production : type : oauth2 description : This API uses OAuth 2 with the authorization code grant flow. flows : authorizationCode : authorizationUrl : https://api.va.gov/oauth2/authorization tokenUrl : https://api.va.gov/oauth2/token scopes : prescription.read : Retrieve prescription data sandbox : type : oauth2 description : This API uses OAuth 2 with the authorization code grant flow. flows : authorizationCode : authorizationUrl : https://sandbox-api.va.gov/oauth2/authorization tokenUrl : https://sandbox-api.va.gov/oauth2/token scopes : prescription.read : Retrieve prescription data responses : # (10) ErrorUnauthorized : description : Unauthorized content : application/json : schema : type : object example : errors : - status : 401 title : Unauthorized detail : Invalid credentials. The access token has expired. ErrorForbidden : description : Forbidden content : application/json : schema : type : object example : errors : - status : 403 title : Forbidden detail : You do not have access to the requested resource. ErrorNotFound : description : Not Found content : application/json : schema : type : object example : errors : - status : 404 title : Not Found detail : The requested resource could not be found. ErrorInternalServerError : description : Internal Server Error content : application/json : schema : type : object example : errors : - status : 500 title : Internal Server Error detail : An internal API error occurred. ErrorBadGateway : description : Bad Gateway content : application/json : schema : type : object example : errors : - status : 502 title : Bad Gateway detail : An upstream service the API depends on returned an error. ErrorServiceUnavailable : description : Service Unavailable content : application/json : schema : type : object example : errors : - status : 503 detail : An upstream service is unavailable. schemas : PharmacyList : type : object required : - data properties : data : type : array items : $ref : \"#/components/schemas/Pharmacy\" # (11) Pharmacy : type : object required : - type - id - attributes properties : type : type : string example : Pharmacy id : type : string example : 6e976911-2707-4018-a6db-0d1342326379 attributes : type : object required : - id - name - city - state - cerner - clinics properties : id : type : string example : \"358\" name : type : string example : \"Cheyenne VA Medical Center Pharmacy\" city : type : string example : \"Cheyenne\" state : $ref : '#/components/schemas/State' PrescriptionList : type : object required : - data properties : data : type : array items : $ref : \"#/components/schemas/Prescription\" Prescription : type : object required : - type - id - attributes properties : type : type : string example : Prescription id : type : string example : db8a52f0-b3d2-4cc9-bcab-7053d88737d5 attributes : type : object required : - productNumber - referenceDrug - brandName - activeIngredients - referenceStandard - dosageForm - route properties : productNumber : type : string example : '001' referenceDrug : type : boolean example : false brandName : type : string example : 'FAMOTIDINE PRESERVATIVE FREE' activeIngredients : type : object required : - name - strength properties : name : type : string example : \"FAMOTIDINE\" strength : type : string example : \"10MG/ML\" referenceStandard : type : boolean example : false dosageForm : type : string enum : [ \"INJECTABLE\" , \"TABLET\" ] # (13) example : \"TABLET\" route : type : string enum : [ \"INJECTION\" , \"ORAL\" ] example : \"ORAL\" State : # (14) type : string enum : - AK - AL - AR - AZ - CA - CO - CT - DE - FL - GA - HI - IA - ID - IL - IN - KS - KY - LA - MA - MD - ME - MI - MN - MO - MS - MT - NC - ND - NE - NH - NJ - NM - NV - NY - OH - OK - OR - PA - RI - SC - SD - TN - TX - UT - VA - VT - WA - WI - WV - WY example : \"WY\" OpenAPI Spec 3.0.x is the required version. Version 3.1 can not be used yet as SwaggerUI does not support it at this time. If you use JSON Schema to define your models, you can set the dialect globally through the jsonSchemaDialect property. The servers section should reflect your API's future external public-facing location when hosted on Lighthouse. All endpoints should then be relative to those base URLs. You can copy the example definition starting on this line (#9) to use in your OAS doc; remember to replace rx with your namespace. Using $ref properties (references) to link to response body schema definitions helps keep your endpoint definitions short. Errors happen. We require that all APIs let consumers know the error schema your API will return should your API encounter an unexpected error. Many VA APIs rely on one or more upstream services for their data. If your API could throw a 500 if an upstream service returns an error, consider returning a 502 error instead, so you and the consumer know a dependency rather than the API is causing the issue. If your API could throw a 500 if an upstream service is down, consider returning a 503 error instead, so you and the consumer know a dependency rather than the API is causing the issue. All endpoints must have a security property. In this example, the endpoint does not require authentication. However, the security tag is still included but it contains an empty object. This lets us know security was left out on purpose. Often, multiple API operations have some common parameters or return the same response structure. To avoid code duplication, you can place the common definitions in the global components section and reference them using $ref . Responses, and specifically errors, are likely to be the same for all endpoints. Defining them within the components/responses can help keep down the size of your path definitions. $refs can have $refs . Think of schemas like their database counterparts. Each model and its relations should be a distinct schema. This endpoint returns a veteran's prescription history, which qualifies as Personal Health Information (PHI). All endpoints that return PII or PHI must use OAuth. Enums should be considered constants. As in 'C' style languages, they should be UPPER_CASE with underscores for spaces. Components don't have to be resources. Any data that appears in multiple locations, such as a list of states, can be a component. Info tags must include a title and a description . Path methods must contain a shorter summary and a longer description that explains the purpose and function of each operation. Requests should use URL or body parameters rather than headers to pass along requisite data unique to that endpoint. Protected endpoints must define 401 Unauthorized and 403 Forbidden responses. The prescription.read scope is required for this endpoint so it is listed in the security section.","title":"Example OAS Document"},{"location":"lifecycle/","text":"Lifecycle \u00b6 As and API version progresses through its lifecycle, consumers test it, use it, and eventually migrate away from it. The lifecycle stages, or states, on Lighthouse are: State Description ONBOARDING The API is in the process of onboarding to Lighthouse. ACTIVE This version of the API is available in production and is fully supported. There may be more than one 'active' version of an API at a time. DEPRECATED This version of the API is available for a fixed period of time. It is fully supported for existing consumers. It is not available to new consumers. Deprecation and Sunset HTTP headers are set to let consumers know that it is deprecated and when the API will be deactivated. DEACTIVATED This version of the API is unpublished from production and no longer available to any consumer. The footprint of all deployed applications entering this state must be completely removed from production, sandbox, and lower environments. This section describes the lifecycle and versioning strategies of APIs on Lighthouse: API Evolution : A strategy for enhancing an API without introducing breaking changes. Versioning : Conventions for versioning an API for major or breaking changes. Deprecation : Retiring a version, endpoint, or a complete API.","title":"Lifecycle"},{"location":"lifecycle/#lifecycle","text":"As and API version progresses through its lifecycle, consumers test it, use it, and eventually migrate away from it. The lifecycle stages, or states, on Lighthouse are: State Description ONBOARDING The API is in the process of onboarding to Lighthouse. ACTIVE This version of the API is available in production and is fully supported. There may be more than one 'active' version of an API at a time. DEPRECATED This version of the API is available for a fixed period of time. It is fully supported for existing consumers. It is not available to new consumers. Deprecation and Sunset HTTP headers are set to let consumers know that it is deprecated and when the API will be deactivated. DEACTIVATED This version of the API is unpublished from production and no longer available to any consumer. The footprint of all deployed applications entering this state must be completely removed from production, sandbox, and lower environments. This section describes the lifecycle and versioning strategies of APIs on Lighthouse: API Evolution : A strategy for enhancing an API without introducing breaking changes. Versioning : Conventions for versioning an API for major or breaking changes. Deprecation : Retiring a version, endpoint, or a complete API.","title":"Lifecycle"},{"location":"lifecycle/api-evolution/","text":"API Evolution \u00b6 API Evolution is an enhancement strategy for APIs where major versioning is unnecessary to fulfill a backward-compatible contract as long as you are adding rather than removing endpoints, fields, and query parameters. Requirement To be non-breaking, and not require versioning, additions must be optional, meaning that all the endpoints function as before and do not break if a consumer application ignores the recent changes. Guidance Providers should design APIs in a forward and extensible way to maintain compatibility and avoid duplication of resources, functionality, and excessive versioning. Extensibility \u00b6 An evolvable API is extensible, but designing for extensibility takes special care and forethought since it's possible for early design decisions to make later extensibility of an API more difficult. The following practices are not extensible: Ordered query or request body parameters Returning one error rather an array of errors in responses Flat data in request and response bodies For example, if a response to a payment history API returned a flat list of payment identifiers, like what is below, then adding additional data--without versioning--would be impossible. 1 2 3 4 5 6 { \"data\" : [ \"37a6c0b9-6033-484f-a707-84649e5c7c35\" , \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , ] } If we later want to return a payment date there is nowhere to attach it. A more extensible solution is to wrap data in an object with named fields. Using a resource in the response is even safer. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"data\" : [ { \"id\" : \"37a6c0b9-6033-484f-a707-84649e5c7c35\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-15T00:00:00Z\" , } }, { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" , } } ] } Extensible names \u00b6 Be specific and detailed when choosing names to avoid future limitations. While an endpoint in your API may initially only return one (mailing) address, like this: 1 2 3 4 5 6 7 8 { \"address\" : { \"street\" : \"3700 North Capitol Street NW #558\" , \"city\" : \"Washington\" , \"state\" : \"DC\" , \"postalCode\" : \"20011\" } } It may need to return both a residential and a mailing address in the future. Using extensible names at the start would allow an easier shift to a response like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"residentialAddress\" : { \"street\" : \"3700 North Capitol Street NW #558\" , \"city\" : \"Washington\" , \"state\" : \"DC\" , \"postalCode\" : \"20011\" }, \"mailingAddress\" : { \"street\" : \"511 10th St NW\" , \"city\" : \"Washington\" , \"state\" : \"DC\" , \"postalCode\" : \"20004\" } } Adding new endpoints \u00b6 Guidance Adding a new endpoint or a method to an existing path is an evolutionary change. Incrementing the major version in these cases is not recommended . Consumers or product owners may consider multiple new endpoints a major change. Still, it is up to the provider to decide if the major version needs to be bumped. Evolving requests \u00b6 Requirement There must NOT be any change in the HTTP verbs (such as GET, POST, and so on) supported by an existing URI. Query-parameters must be unordered. New query parameters appended to URIs must be optional. Renaming endpoint paths \u00b6 If an endpoint's path needs to be renamed, a provider should do so in an additive manner so that it is effectively a new endpoint with the same functionality. The provider should keep and mark the old endpoint as deprecated . Adding query parameters \u00b6 While providers should only do so in moderation, adding optional query parameters can avoid versioning an API due to relatively minor changes in functionality. For example, if we wanted to add pagination to a resource collection endpoint that was previously not paged, such as: 1 ../v0/claims then we could append optional pageNumber and pageSize query parameters to the request, like this: 1 ../v0/claims?pageNumber=2&pageSize=10 As long as the original call signature of the endpoint functions as before, meaning it continues not to page without the new query params, then no versioning is necessary. Evolving responses \u00b6 Requirement There must NOT be any change in the HTTP status codes returned by the URIs. There must NOT be any change in the name and type of the request or response headers of an URI. New headers must be optional. Adding fields \u00b6 As shown in the Extensibility section above, adding fields as long as they are within an object would not require versioning because adding fields is an additive change, which existing consumer apps could ignore. For example: Before the addition 1 2 3 4 5 6 7 8 { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" } } After the addition 1 2 3 4 5 6 7 8 9 { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" , \"paymentMethod\" : \"DIRECT_DEPOSIT\" } } Renaming fields \u00b6 If a field needs to be renamed, you should do so in an additive manner and not remove the old field. Instead, mark the old field as deprecated . While this results in some duplication over the sunset period for the old name, it will not break applications still expecting that field. For example, if a provider needed to add a second date to an object that already had a date field, you could rename the old one for clarity. Adding \u2018approvalDate\u2019 and renaming \u2018date\u2019 to \u2018paymentDate\u2019 1 2 3 4 5 6 7 8 9 10 { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" , // marked as depreca te d i n t he OAS \"approvalDate\" : \"2019-07-31T00:00:00Z\" , \"paymentDate\" : \"2019-12-31T00:00:00Z\" } }","title":"API Evolution"},{"location":"lifecycle/api-evolution/#api-evolution","text":"API Evolution is an enhancement strategy for APIs where major versioning is unnecessary to fulfill a backward-compatible contract as long as you are adding rather than removing endpoints, fields, and query parameters. Requirement To be non-breaking, and not require versioning, additions must be optional, meaning that all the endpoints function as before and do not break if a consumer application ignores the recent changes. Guidance Providers should design APIs in a forward and extensible way to maintain compatibility and avoid duplication of resources, functionality, and excessive versioning.","title":"API Evolution"},{"location":"lifecycle/api-evolution/#extensibility","text":"An evolvable API is extensible, but designing for extensibility takes special care and forethought since it's possible for early design decisions to make later extensibility of an API more difficult. The following practices are not extensible: Ordered query or request body parameters Returning one error rather an array of errors in responses Flat data in request and response bodies For example, if a response to a payment history API returned a flat list of payment identifiers, like what is below, then adding additional data--without versioning--would be impossible. 1 2 3 4 5 6 { \"data\" : [ \"37a6c0b9-6033-484f-a707-84649e5c7c35\" , \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , ] } If we later want to return a payment date there is nowhere to attach it. A more extensible solution is to wrap data in an object with named fields. Using a resource in the response is even safer. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"data\" : [ { \"id\" : \"37a6c0b9-6033-484f-a707-84649e5c7c35\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-15T00:00:00Z\" , } }, { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" , } } ] }","title":"Extensibility"},{"location":"lifecycle/api-evolution/#extensible-names","text":"Be specific and detailed when choosing names to avoid future limitations. While an endpoint in your API may initially only return one (mailing) address, like this: 1 2 3 4 5 6 7 8 { \"address\" : { \"street\" : \"3700 North Capitol Street NW #558\" , \"city\" : \"Washington\" , \"state\" : \"DC\" , \"postalCode\" : \"20011\" } } It may need to return both a residential and a mailing address in the future. Using extensible names at the start would allow an easier shift to a response like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"residentialAddress\" : { \"street\" : \"3700 North Capitol Street NW #558\" , \"city\" : \"Washington\" , \"state\" : \"DC\" , \"postalCode\" : \"20011\" }, \"mailingAddress\" : { \"street\" : \"511 10th St NW\" , \"city\" : \"Washington\" , \"state\" : \"DC\" , \"postalCode\" : \"20004\" } }","title":"Extensible names"},{"location":"lifecycle/api-evolution/#adding-new-endpoints","text":"Guidance Adding a new endpoint or a method to an existing path is an evolutionary change. Incrementing the major version in these cases is not recommended . Consumers or product owners may consider multiple new endpoints a major change. Still, it is up to the provider to decide if the major version needs to be bumped.","title":"Adding new endpoints"},{"location":"lifecycle/api-evolution/#evolving-requests","text":"Requirement There must NOT be any change in the HTTP verbs (such as GET, POST, and so on) supported by an existing URI. Query-parameters must be unordered. New query parameters appended to URIs must be optional.","title":"Evolving requests"},{"location":"lifecycle/api-evolution/#renaming-endpoint-paths","text":"If an endpoint's path needs to be renamed, a provider should do so in an additive manner so that it is effectively a new endpoint with the same functionality. The provider should keep and mark the old endpoint as deprecated .","title":"Renaming endpoint paths"},{"location":"lifecycle/api-evolution/#adding-query-parameters","text":"While providers should only do so in moderation, adding optional query parameters can avoid versioning an API due to relatively minor changes in functionality. For example, if we wanted to add pagination to a resource collection endpoint that was previously not paged, such as: 1 ../v0/claims then we could append optional pageNumber and pageSize query parameters to the request, like this: 1 ../v0/claims?pageNumber=2&pageSize=10 As long as the original call signature of the endpoint functions as before, meaning it continues not to page without the new query params, then no versioning is necessary.","title":"Adding query parameters"},{"location":"lifecycle/api-evolution/#evolving-responses","text":"Requirement There must NOT be any change in the HTTP status codes returned by the URIs. There must NOT be any change in the name and type of the request or response headers of an URI. New headers must be optional.","title":"Evolving responses"},{"location":"lifecycle/api-evolution/#adding-fields","text":"As shown in the Extensibility section above, adding fields as long as they are within an object would not require versioning because adding fields is an additive change, which existing consumer apps could ignore. For example: Before the addition 1 2 3 4 5 6 7 8 { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" } } After the addition 1 2 3 4 5 6 7 8 9 { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" , \"paymentMethod\" : \"DIRECT_DEPOSIT\" } }","title":"Adding fields"},{"location":"lifecycle/api-evolution/#renaming-fields","text":"If a field needs to be renamed, you should do so in an additive manner and not remove the old field. Instead, mark the old field as deprecated . While this results in some duplication over the sunset period for the old name, it will not break applications still expecting that field. For example, if a provider needed to add a second date to an object that already had a date field, you could rename the old one for clarity. Adding \u2018approvalDate\u2019 and renaming \u2018date\u2019 to \u2018paymentDate\u2019 1 2 3 4 5 6 7 8 9 10 { \"id\" : \"2c7a317a-40d0-4ec7-92ef-df954a6f2818\" , \"type\" : \"PaymentHistory\" , \"attributes\" : { \"amount\" : \"$3,444.70\" , \"date\" : \"2019-12-31T00:00:00Z\" , // marked as depreca te d i n t he OAS \"approvalDate\" : \"2019-07-31T00:00:00Z\" , \"paymentDate\" : \"2019-12-31T00:00:00Z\" } }","title":"Renaming fields"},{"location":"lifecycle/deprecation/","text":"Deprecation \u00b6 APIs that teams have replaced with newer versions or are no longer meeting technical, business, or security objectives should be deprecated. However, it\u2019s important to remember that teams at the VA often have different priorities, budgets, and release schedules and may have a long runway to migrate away from a deprecated API. Therefore, we recommend that API teams keep an API in a deprecated state for at least six months before deactivating it. Also, note that some clients, such as mobile applications, may be unable to control when users update a consuming application. Therefore, it may take up to a year for the user base to transition to a version of the app that no longer uses the deprecated API. The goal of deprecation is to progress to a state where no consumers use the API. Getting to this state depends on clear, timely, and detailed documentation, communication, and monitoring. Requirement Providers must return deprecation and an optional sunset header in deprecated endpoint's responses. Guidance Providers should define a sunset period for the API they are deprecating. This period is up to the provider, but we recommend at least six months. Providers should have a plan for communicating the deprecation and the sunset period to all consumers of the API. Providers should monitor the deprecated API to ensure its use is declining over the sunset period. Headers \u00b6 The Internet Engineering Task Force has specified two headers for deprecation. \u2018Deprecation\u2019 and \u2018Sunset.\u2019 Both headers seem similar, and that the Deprecation header can take a boolean value or a timestamp can cause further confusion. Deprecation in the context of an API means active but no longer enhanced, e.g., the API is not the latest version, and the development team is no longer adding new features or fixing bugs, but consumers can still access it. Sunset means deactivated; the API is no longer accessible at all. Deprecation header \u00b6 This header is used to mark an API as deprecated or slated for deprecation at a future date. Use a boolean true value to set the API as actively deprecated. 1 Deprecation: true If deprecation starts at a future date, use an HTTP-date timestamp. 1 Deprecation: Thu, 11 Nov 2048 23:59:59 UTC Sunset header \u00b6 The sunset header always takes an HTTP-date timestamp and represents the date that a provider will remove the API. 1 2 Deprecation: true Sunset: Thu, 11 Nov 2049 23:59:59 UTC Documenting deprecations \u00b6 Between versions, an API team may want to deprecate an endpoint or an element of an API rather than the entire thing. The OpenAPI Specification uses a deprecated field to mark complete endpoints or their specific elements as deprecated. Requirement Providers must document deprecated endpoints and elements in the OAS. Deprecated API endpoints and elements must remain supported for the life of the major version. HTTP methods \u00b6 1 2 3 4 5 paths : /appeals : get : description : Deprecated endpoint to retrieve appeals deprecated : true Query parameters \u00b6 1 2 3 4 5 6 7 8 9 paths : /appeals : get : description : Retrieve appeals status parameters : - name : fromDate in : query description : Deprecated start date of appeal deprecated : true Headers \u00b6 1 2 3 4 5 6 7 8 9 paths : /appeals : get : description : Retrieve appeals status parameters : - name : ORG-Authorization-Token in : header description : Deprecated ORG-Authorization-Token header deprecated : true Properties in a resource \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 paths : /appeals : get : description : Retrieve appeals status responses : 200 : description : Successful appeal content : application/json : schema : $ref : \u201c#/components/schemas/Appeal\u201d components : schemas : Appeal : description : Appeal status schema properties : appealType : type : string description : The decision review option chosen by the appellant deprecated : true","title":"Deprecation"},{"location":"lifecycle/deprecation/#deprecation","text":"APIs that teams have replaced with newer versions or are no longer meeting technical, business, or security objectives should be deprecated. However, it\u2019s important to remember that teams at the VA often have different priorities, budgets, and release schedules and may have a long runway to migrate away from a deprecated API. Therefore, we recommend that API teams keep an API in a deprecated state for at least six months before deactivating it. Also, note that some clients, such as mobile applications, may be unable to control when users update a consuming application. Therefore, it may take up to a year for the user base to transition to a version of the app that no longer uses the deprecated API. The goal of deprecation is to progress to a state where no consumers use the API. Getting to this state depends on clear, timely, and detailed documentation, communication, and monitoring. Requirement Providers must return deprecation and an optional sunset header in deprecated endpoint's responses. Guidance Providers should define a sunset period for the API they are deprecating. This period is up to the provider, but we recommend at least six months. Providers should have a plan for communicating the deprecation and the sunset period to all consumers of the API. Providers should monitor the deprecated API to ensure its use is declining over the sunset period.","title":"Deprecation"},{"location":"lifecycle/deprecation/#headers","text":"The Internet Engineering Task Force has specified two headers for deprecation. \u2018Deprecation\u2019 and \u2018Sunset.\u2019 Both headers seem similar, and that the Deprecation header can take a boolean value or a timestamp can cause further confusion. Deprecation in the context of an API means active but no longer enhanced, e.g., the API is not the latest version, and the development team is no longer adding new features or fixing bugs, but consumers can still access it. Sunset means deactivated; the API is no longer accessible at all.","title":"Headers"},{"location":"lifecycle/deprecation/#deprecation-header","text":"This header is used to mark an API as deprecated or slated for deprecation at a future date. Use a boolean true value to set the API as actively deprecated. 1 Deprecation: true If deprecation starts at a future date, use an HTTP-date timestamp. 1 Deprecation: Thu, 11 Nov 2048 23:59:59 UTC","title":"Deprecation header"},{"location":"lifecycle/deprecation/#sunset-header","text":"The sunset header always takes an HTTP-date timestamp and represents the date that a provider will remove the API. 1 2 Deprecation: true Sunset: Thu, 11 Nov 2049 23:59:59 UTC","title":"Sunset header"},{"location":"lifecycle/deprecation/#documenting-deprecations","text":"Between versions, an API team may want to deprecate an endpoint or an element of an API rather than the entire thing. The OpenAPI Specification uses a deprecated field to mark complete endpoints or their specific elements as deprecated. Requirement Providers must document deprecated endpoints and elements in the OAS. Deprecated API endpoints and elements must remain supported for the life of the major version.","title":"Documenting deprecations"},{"location":"lifecycle/deprecation/#http-methods","text":"1 2 3 4 5 paths : /appeals : get : description : Deprecated endpoint to retrieve appeals deprecated : true","title":"HTTP methods"},{"location":"lifecycle/deprecation/#query-parameters","text":"1 2 3 4 5 6 7 8 9 paths : /appeals : get : description : Retrieve appeals status parameters : - name : fromDate in : query description : Deprecated start date of appeal deprecated : true","title":"Query parameters"},{"location":"lifecycle/deprecation/#headers_1","text":"1 2 3 4 5 6 7 8 9 paths : /appeals : get : description : Retrieve appeals status parameters : - name : ORG-Authorization-Token in : header description : Deprecated ORG-Authorization-Token header deprecated : true","title":"Headers"},{"location":"lifecycle/deprecation/#properties-in-a-resource","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 paths : /appeals : get : description : Retrieve appeals status responses : 200 : description : Successful appeal content : application/json : schema : $ref : \u201c#/components/schemas/Appeal\u201d components : schemas : Appeal : description : Appeal status schema properties : appealType : type : string description : The decision review option chosen by the appellant deprecated : true","title":"Properties in a resource"},{"location":"lifecycle/versioning/","text":"Versioning \u00b6 Requirement External APIs must increment the major version within their URI if they introduce a breaking change. Internal APIs with over one consumer must increment the major version within their URI if they introduce a breaking change. Release notes must accompany each major and minor release. Guidance It is optional to increment the major version within their URI when introducing a breaking change if it is an internal API with only one consumer AND if the consumer\u2019s clients can be updated at the same time as the API. An example of this would be a web app pushed out to all clients vs. a mobile app where updates roll out more slowly. It's optional but recommended to publish release notes for patch versions. Breaking change definition \u00b6 At a high level, a breaking change is any change to an API that would cause an error in a consuming application. The following are all examples of breaking changes: Removing an endpoint Renaming an endpoint\u2019s path Removing an HTTP verb (GET, POST, and so on) for an endpoint Removing a property Renaming a property Changing a properties-level or tier within an object\u2019s hierarchy Making a mandatory property optional Changing a property\u2019s type Changing a property\u2019s format Adding or removing values from an enum API versioning scheme \u00b6 Requirement APIs must only use URI (non-header)-based major versioning. APIs must provide a major version number in the URI path after the namespace and before any resources/operations. The versioning scheme must start with the lowercase character v followed by an integer, the combination of which produces an ordinal number, e.g. v0 , v1 , v2 . APIs must NOT expose minor or patch version numbers in the URI path. A minor API version must maintain backward compatibility with all previous minor versions within the same major version. For non-major changes, providers must still update the minor or patch versions in the OAS documentation. Guidance Versioning should start at v0 . Versioning may start with another ordinal number if the API is being ported to Lighthouse. The major version after the namespace. 1 https://api.va.gov/benefits/v0 Resources or operations specific to the endpoints within the API then show up after the version number. 1 https://api.va.gov/benefits/v0/claims Incrementing minor and patch versions \u00b6 Requirement Backward-compatible changes that introduce new endpoints or new fields within existing endpoints must be released within a new minor version. Changes to the API's underlying service, or upstream services, that do not update its interface or cause any new side effects to the underlying system's data must be released as a patch version. Minor version releases must not change the major version within the URI. Guidance Creating a new OAS doc for each minor version can result in many files that are virtually the same. Use ' reference definitions ', $ref , to reduce duplication and share definitions across OAS docs. As minor and patch version information is not in the URI path, minor changes must only be documented in the OAS doc for the API. Before 1 2 3 4 info : title : Benefits API ... version : 1.0.0 After 1 2 3 4 info : title : Benefits API ... version : 1.1.0 Release Notes \u00b6 When should API teams publish release notes? Whenever an API changes in a way that could affect a consumer's implementation. This is regardless of whether the change is within a major, minor, or patch release (Major.Minor.Patch). The first criterion for publishing release notes is when the OpenAPI specification for the API changes accompanying release notes must be published. In semantic versioning, this would be a major or minor change. API teams may optionally publish releases for changes internal to the API and are abstracted away from the end user. This is almost always a patch change. For example, iPhone security updates do not affect the UI and are released - with a one-sentence release note - as a patch version, e.g., iOS 14.8.1. The second is when a release causes a change in behavior in the underlying system. i.e., an endpoint with the same contract as before, when now called, has a different effect on its system or upstream systems. In summary, API teams must publish release notes when the API's interface changes or the system's behavior changes. API teams may optionally publish release notes when a change is internal and does not update the interface or cause any new side effects to the underlying system's data.","title":"Versioning"},{"location":"lifecycle/versioning/#versioning","text":"Requirement External APIs must increment the major version within their URI if they introduce a breaking change. Internal APIs with over one consumer must increment the major version within their URI if they introduce a breaking change. Release notes must accompany each major and minor release. Guidance It is optional to increment the major version within their URI when introducing a breaking change if it is an internal API with only one consumer AND if the consumer\u2019s clients can be updated at the same time as the API. An example of this would be a web app pushed out to all clients vs. a mobile app where updates roll out more slowly. It's optional but recommended to publish release notes for patch versions.","title":"Versioning"},{"location":"lifecycle/versioning/#breaking-change-definition","text":"At a high level, a breaking change is any change to an API that would cause an error in a consuming application. The following are all examples of breaking changes: Removing an endpoint Renaming an endpoint\u2019s path Removing an HTTP verb (GET, POST, and so on) for an endpoint Removing a property Renaming a property Changing a properties-level or tier within an object\u2019s hierarchy Making a mandatory property optional Changing a property\u2019s type Changing a property\u2019s format Adding or removing values from an enum","title":"Breaking change definition"},{"location":"lifecycle/versioning/#api-versioning-scheme","text":"Requirement APIs must only use URI (non-header)-based major versioning. APIs must provide a major version number in the URI path after the namespace and before any resources/operations. The versioning scheme must start with the lowercase character v followed by an integer, the combination of which produces an ordinal number, e.g. v0 , v1 , v2 . APIs must NOT expose minor or patch version numbers in the URI path. A minor API version must maintain backward compatibility with all previous minor versions within the same major version. For non-major changes, providers must still update the minor or patch versions in the OAS documentation. Guidance Versioning should start at v0 . Versioning may start with another ordinal number if the API is being ported to Lighthouse. The major version after the namespace. 1 https://api.va.gov/benefits/v0 Resources or operations specific to the endpoints within the API then show up after the version number. 1 https://api.va.gov/benefits/v0/claims","title":"API versioning scheme"},{"location":"lifecycle/versioning/#incrementing-minor-and-patch-versions","text":"Requirement Backward-compatible changes that introduce new endpoints or new fields within existing endpoints must be released within a new minor version. Changes to the API's underlying service, or upstream services, that do not update its interface or cause any new side effects to the underlying system's data must be released as a patch version. Minor version releases must not change the major version within the URI. Guidance Creating a new OAS doc for each minor version can result in many files that are virtually the same. Use ' reference definitions ', $ref , to reduce duplication and share definitions across OAS docs. As minor and patch version information is not in the URI path, minor changes must only be documented in the OAS doc for the API. Before 1 2 3 4 info : title : Benefits API ... version : 1.0.0 After 1 2 3 4 info : title : Benefits API ... version : 1.1.0","title":"Incrementing minor and patch versions"},{"location":"lifecycle/versioning/#release-notes","text":"When should API teams publish release notes? Whenever an API changes in a way that could affect a consumer's implementation. This is regardless of whether the change is within a major, minor, or patch release (Major.Minor.Patch). The first criterion for publishing release notes is when the OpenAPI specification for the API changes accompanying release notes must be published. In semantic versioning, this would be a major or minor change. API teams may optionally publish releases for changes internal to the API and are abstracted away from the end user. This is almost always a patch change. For example, iPhone security updates do not affect the UI and are released - with a one-sentence release note - as a patch version, e.g., iOS 14.8.1. The second is when a release causes a change in behavior in the underlying system. i.e., an endpoint with the same contract as before, when now called, has a different effect on its system or upstream systems. In summary, API teams must publish release notes when the API's interface changes or the system's behavior changes. API teams may optionally publish release notes when a change is internal and does not update the interface or cause any new side effects to the underlying system's data.","title":"Release Notes"},{"location":"monitoring/","text":"Monitoring \u00b6 Health Checks \u00b6 Requirement Each version of an API must have a unique health check endpoint. APIs must not repurpose application endpoints as health checks. Lighthouse\u2019s internal monitoring tools require that each version of an API has a health check endpoint. This is because some APIs deploy versions on different infrastructure, and versions that share infrastructure now may not always do so in the future. However, if two versions of an API do share infrastructure, you may route each version's health check endpoints to the same controller. Health checks vary in complexity between APIs. At a minimum, the health check should confirm that requests are successfully being routed, through the gateway and VA network, to your application. More holistic health checks may validate that the application\u2019s internal dependencies, such as data stores and upstream services, are up and operating without error. Health checks are required to be standalone endpoints rather than repurposed endpoints that return application resources. This ensures that the health check is free of caching, auth, and business logic. Example URI and Responses \u00b6 Requirement Health check endpoints must not require authentication. Health check endpoints must return a 200 response code if the API is up. Health check endpoints must return a 5xx level response code if the API is down. Below is an example health check URI and response for a fictional 'Rx' API on Lighthouse. 1 GET https://api.va.gov/services/rx/v1/healthcheck There is not a finalized RFC for healthcheck responses. A draft proposal outlines a potential response of which only status is required with one of the following values: pass with 200 response code, the API is available and functioning as expected. fail with 5xx response code, the API is unavailable or throwing errors. If the health check response itself is down the Lighthouse gateway will return a 503 response. warn with 2xx-3xx response code range. The API is up but having intermittent issues. 200 OK 1 2 3 4 5 { \"status\" : \"pass\" , \"version\" : \"1\" , \"releaseId\" : \"1.2.2\" , } 503 Service Unavailable 1 2 3 4 5 { \"status\" : \"fail\" , \"version\" : \"1\" , \"releaseId\" : \"1.2.2\" , } Accessibility \u00b6 APIs must provide a health check endpoint that Lighthouse monitoring tools can access so they can monitor the status of the API. API consumers can then take appropriate action if an API cannot handle requests or is unhealthy. The health check endpoint or endpoints made available to consumers of an API must not provide internal or sensitive information within the response. In addition, the health check must reflect the state of the interface, not the service behind that interface.","title":"Monitoring"},{"location":"monitoring/#monitoring","text":"","title":"Monitoring"},{"location":"monitoring/#health-checks","text":"Requirement Each version of an API must have a unique health check endpoint. APIs must not repurpose application endpoints as health checks. Lighthouse\u2019s internal monitoring tools require that each version of an API has a health check endpoint. This is because some APIs deploy versions on different infrastructure, and versions that share infrastructure now may not always do so in the future. However, if two versions of an API do share infrastructure, you may route each version's health check endpoints to the same controller. Health checks vary in complexity between APIs. At a minimum, the health check should confirm that requests are successfully being routed, through the gateway and VA network, to your application. More holistic health checks may validate that the application\u2019s internal dependencies, such as data stores and upstream services, are up and operating without error. Health checks are required to be standalone endpoints rather than repurposed endpoints that return application resources. This ensures that the health check is free of caching, auth, and business logic.","title":"Health Checks"},{"location":"monitoring/#example-uri-and-responses","text":"Requirement Health check endpoints must not require authentication. Health check endpoints must return a 200 response code if the API is up. Health check endpoints must return a 5xx level response code if the API is down. Below is an example health check URI and response for a fictional 'Rx' API on Lighthouse. 1 GET https://api.va.gov/services/rx/v1/healthcheck There is not a finalized RFC for healthcheck responses. A draft proposal outlines a potential response of which only status is required with one of the following values: pass with 200 response code, the API is available and functioning as expected. fail with 5xx response code, the API is unavailable or throwing errors. If the health check response itself is down the Lighthouse gateway will return a 503 response. warn with 2xx-3xx response code range. The API is up but having intermittent issues. 200 OK 1 2 3 4 5 { \"status\" : \"pass\" , \"version\" : \"1\" , \"releaseId\" : \"1.2.2\" , } 503 Service Unavailable 1 2 3 4 5 { \"status\" : \"fail\" , \"version\" : \"1\" , \"releaseId\" : \"1.2.2\" , }","title":"Example URI and Responses"},{"location":"monitoring/#accessibility","text":"APIs must provide a health check endpoint that Lighthouse monitoring tools can access so they can monitor the status of the API. API consumers can then take appropriate action if an API cannot handle requests or is unhealthy. The health check endpoint or endpoints made available to consumers of an API must not provide internal or sensitive information within the response. In addition, the health check must reflect the state of the interface, not the service behind that interface.","title":"Accessibility"},{"location":"naming-and-formatting/","text":"Naming & Formatting \u00b6 Guidance Fields should use camelCase. Acronyms should be camelCase rather than uppercase. Providers should avoid abbreviations. Booleans should be prefixed with an auxiliary verb (such as is, has, or can). Enums should be UPPER_CASE strings with underscores in place of spaces. Case \u00b6 Lighthouse recommends using camelCase rather than snake_case or kebab-case for JSON field names. Providers can use any programming language for their applications, including C-style languages (Ruby, Python, etc.) whose style guides/communities have decided on snake case for variable and field names. That said, we need to pick one case, and JavaScript is the dominant language for web clients/API consumers (and the J in JSON), and it uses came case. Acronyms \u00b6 Acronyms are usually written in uppercase, which can confuse consumers reading field names. Most programming languages reserve uppercase for constants. Also, with camel case field names, it's hard to tell where the acronym ends and the next part of the variable begins, e.g., BIRLSId vs. birlsId . Abbreviations \u00b6 For clarity, it's better to spell a word completely rather than use an abbreviation, especially a non-standard one. Modern editors and IDEs can autocomplete variable names, so abbreviations no longer save keystrokes. The VA has complicated terminology; future developers or your future self will appreciate the lack of ambiguity. Booleans \u00b6 JSON is not typed, so prefixing boolean fields with an auxiliary verb (such as is, has, or can) marks it as a boolean field. This is also closer to natural language, e.g., run this code if the user is a veteran becomes if (isVeteran) {} .","title":"Naming & Formatting"},{"location":"naming-and-formatting/#naming-formatting","text":"Guidance Fields should use camelCase. Acronyms should be camelCase rather than uppercase. Providers should avoid abbreviations. Booleans should be prefixed with an auxiliary verb (such as is, has, or can). Enums should be UPPER_CASE strings with underscores in place of spaces.","title":"Naming &amp; Formatting"},{"location":"naming-and-formatting/#case","text":"Lighthouse recommends using camelCase rather than snake_case or kebab-case for JSON field names. Providers can use any programming language for their applications, including C-style languages (Ruby, Python, etc.) whose style guides/communities have decided on snake case for variable and field names. That said, we need to pick one case, and JavaScript is the dominant language for web clients/API consumers (and the J in JSON), and it uses came case.","title":"Case"},{"location":"naming-and-formatting/#acronyms","text":"Acronyms are usually written in uppercase, which can confuse consumers reading field names. Most programming languages reserve uppercase for constants. Also, with camel case field names, it's hard to tell where the acronym ends and the next part of the variable begins, e.g., BIRLSId vs. birlsId .","title":"Acronyms"},{"location":"naming-and-formatting/#abbreviations","text":"For clarity, it's better to spell a word completely rather than use an abbreviation, especially a non-standard one. Modern editors and IDEs can autocomplete variable names, so abbreviations no longer save keystrokes. The VA has complicated terminology; future developers or your future self will appreciate the lack of ambiguity.","title":"Abbreviations"},{"location":"naming-and-formatting/#booleans","text":"JSON is not typed, so prefixing boolean fields with an auxiliary verb (such as is, has, or can) marks it as a boolean field. This is also closer to natural language, e.g., run this code if the user is a veteran becomes if (isVeteran) {} .","title":"Booleans"},{"location":"naming-and-formatting/addresses/","text":"Addresses \u00b6 APIs are free to format data, including address data, as best fits the needs of their consumers. However, if providers are looking for a suggested schema for an address data type, we suggest following the one the VA Profile team uses. The schema has separate fields for international country subdivisions ( province rather than state ), and postal codes ( internationalPostalCode rather than zipcode ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 { \"$schema\" : \"http://json-schema.org/draft-04/schema\" , \"type\" : \"object\" , \"required\" : [ \"addressLine1\" , \"addressLine2\" , \"addressLine3\" , \"addressPou\" , \"addressType\" , \"city\" , \"internationalPostalCode\" , \"province\" , \"stateCode\" , \"zipCode\" , \"zipCodeSuffix\" ], \"properties\" : { \"id\" : { \"type\" : \"integer\" }, \"addressLine1\" : { \"type\" : \"string\" }, \"addressLine2\" : { \"type\" : [ \"string\" , \"null\" ] }, \"addressLine3\" : { \"type\" : [ \"string\" , \"null\" ] }, \"addressPou\" : { \"type\" : \"string\" }, \"addressType\" : { \"type\" : \"string\" }, \"city\" : { \"type\" : \"string\" }, \"countryCodeIso3\" : { \"type\" : \"string\" }, \"internationalPostalCode\" : { \"type\" : [ \"string\" , \"null\" ] }, \"province\" : { \"type\" : [ \"string\" , \"null\" ] }, \"stateCode\" : { \"type\" : \"string\" }, \"zipCode\" : { \"type\" : \"string\" }, \"zipCodeSuffix\" : { \"type\" : [ \"string\" , \"null\" ] } } } Country codes \u00b6 Guidance Country codes should use ISO 3166-1 alpha-3 . All other country subdivisions (Canadian provinces, Mexican states, UK counties, etc.) should also use the second part of their ISO 3166-2 code . US state and territory codes \u00b6 Guidance US state codes should use the USPS postal abbreviation, which is the second part of a ISO 3166-2:US code. Use the two letter United States Postal Service abbreviation for US states, the District of Columbia, US territories, Air/Army Post Office (APO) and Fleet Post Office (FPO). States \u00b6 Name Abbreviation Alaska AK Alabama AL Arkansas AR Arizona AZ California CA Colorado CO Connecticut CT Delaware DE Florida FL Georgia GA Hawaii HI Iowa IA Idaho ID Illinois IL Indiana IN Kansas KS Kentucky KY Louisiana LA Massachusetts MA Maryland MD Maine ME Michigan MI Minnesota MN Missouri MO Mississippi MS Montana MT North Carolina NC North Dakota ND Nebraska NE New Hampshire NH New Jersey NJ New Mexico NM Nevada NV New York NY Ohio OH Oklahoma OK Oregon OR Pennsylvania PA Rhode Island RI South Carolina SC South Dakota SD Tennessee TN Texas TX Utah UT Virginia VA Vermont VT Washington WA Wisconsin WI West Virginia WV Wyoming WY Districts \u00b6 Name Abbreviation District of Columbia DC Territories \u00b6 Name Abbreviation American Samoa AS Guam GU Northern Mariana Islands MP Puerto Rico PR U.S. Virgin Islands VI Military AFO/FPOs \u00b6 Name Abbreviation Armed Forces Americas AA Armed Forces Europe, Canada, Middle East, and Africa AE Armed Forces Pacific AP","title":"Addresses"},{"location":"naming-and-formatting/addresses/#addresses","text":"APIs are free to format data, including address data, as best fits the needs of their consumers. However, if providers are looking for a suggested schema for an address data type, we suggest following the one the VA Profile team uses. The schema has separate fields for international country subdivisions ( province rather than state ), and postal codes ( internationalPostalCode rather than zipcode ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 { \"$schema\" : \"http://json-schema.org/draft-04/schema\" , \"type\" : \"object\" , \"required\" : [ \"addressLine1\" , \"addressLine2\" , \"addressLine3\" , \"addressPou\" , \"addressType\" , \"city\" , \"internationalPostalCode\" , \"province\" , \"stateCode\" , \"zipCode\" , \"zipCodeSuffix\" ], \"properties\" : { \"id\" : { \"type\" : \"integer\" }, \"addressLine1\" : { \"type\" : \"string\" }, \"addressLine2\" : { \"type\" : [ \"string\" , \"null\" ] }, \"addressLine3\" : { \"type\" : [ \"string\" , \"null\" ] }, \"addressPou\" : { \"type\" : \"string\" }, \"addressType\" : { \"type\" : \"string\" }, \"city\" : { \"type\" : \"string\" }, \"countryCodeIso3\" : { \"type\" : \"string\" }, \"internationalPostalCode\" : { \"type\" : [ \"string\" , \"null\" ] }, \"province\" : { \"type\" : [ \"string\" , \"null\" ] }, \"stateCode\" : { \"type\" : \"string\" }, \"zipCode\" : { \"type\" : \"string\" }, \"zipCodeSuffix\" : { \"type\" : [ \"string\" , \"null\" ] } } }","title":"Addresses"},{"location":"naming-and-formatting/addresses/#country-codes","text":"Guidance Country codes should use ISO 3166-1 alpha-3 . All other country subdivisions (Canadian provinces, Mexican states, UK counties, etc.) should also use the second part of their ISO 3166-2 code .","title":"Country codes"},{"location":"naming-and-formatting/addresses/#us-state-and-territory-codes","text":"Guidance US state codes should use the USPS postal abbreviation, which is the second part of a ISO 3166-2:US code. Use the two letter United States Postal Service abbreviation for US states, the District of Columbia, US territories, Air/Army Post Office (APO) and Fleet Post Office (FPO).","title":"US state and territory codes"},{"location":"naming-and-formatting/addresses/#states","text":"Name Abbreviation Alaska AK Alabama AL Arkansas AR Arizona AZ California CA Colorado CO Connecticut CT Delaware DE Florida FL Georgia GA Hawaii HI Iowa IA Idaho ID Illinois IL Indiana IN Kansas KS Kentucky KY Louisiana LA Massachusetts MA Maryland MD Maine ME Michigan MI Minnesota MN Missouri MO Mississippi MS Montana MT North Carolina NC North Dakota ND Nebraska NE New Hampshire NH New Jersey NJ New Mexico NM Nevada NV New York NY Ohio OH Oklahoma OK Oregon OR Pennsylvania PA Rhode Island RI South Carolina SC South Dakota SD Tennessee TN Texas TX Utah UT Virginia VA Vermont VT Washington WA Wisconsin WI West Virginia WV Wyoming WY","title":"States"},{"location":"naming-and-formatting/addresses/#districts","text":"Name Abbreviation District of Columbia DC","title":"Districts"},{"location":"naming-and-formatting/addresses/#territories","text":"Name Abbreviation American Samoa AS Guam GU Northern Mariana Islands MP Puerto Rico PR U.S. Virgin Islands VI","title":"Territories"},{"location":"naming-and-formatting/addresses/#military-afofpos","text":"Name Abbreviation Armed Forces Americas AA Armed Forces Europe, Canada, Middle East, and Africa AE Armed Forces Pacific AP","title":"Military AFO/FPOs"},{"location":"naming-and-formatting/currency/","text":"Currency & Money \u00b6 Guidance All monetary amounts should be displayed in United States Dollars (USD). Values should include the dollar symbol to the left of the amount, with no space. Cents should be displayed using decimals and a fractional separator. Amounts less than a dollar should start with a zero followed by a decimal. Thousands should be separated by commas. Return monetary values as strings prefixed by a US dollar symbol. One thousand dollars and ten cents 1 2 3 { \"paymentAmount\" : \"$1,000.10\" } Exact dollar values should still display cents. One thousand dollars 1 2 3 { \"paymentAmount\" : \"$1,000.00\" } Values less than one dollar are returned in relation to dollars. Ten cents 1 2 3 { \"paymentAmount\" : \"$0.10\" }","title":"Currency"},{"location":"naming-and-formatting/currency/#currency-money","text":"Guidance All monetary amounts should be displayed in United States Dollars (USD). Values should include the dollar symbol to the left of the amount, with no space. Cents should be displayed using decimals and a fractional separator. Amounts less than a dollar should start with a zero followed by a decimal. Thousands should be separated by commas. Return monetary values as strings prefixed by a US dollar symbol. One thousand dollars and ten cents 1 2 3 { \"paymentAmount\" : \"$1,000.10\" } Exact dollar values should still display cents. One thousand dollars 1 2 3 { \"paymentAmount\" : \"$1,000.00\" } Values less than one dollar are returned in relation to dollars. Ten cents 1 2 3 { \"paymentAmount\" : \"$0.10\" }","title":"Currency &amp; Money"},{"location":"naming-and-formatting/dates/","text":"Dates & Time \u00b6 Requirement Dates and timestamps must follow the ISO 8601 standard . Guidance Dates and timestamps should be in Coordinated Universal Time (UTC) . Timestamps should NOT use offsets . Durations should follow the ISO 8601 standard . Time Intervals should follow the ISO 8601 standard . Dates \u00b6 If your field only needs a date rather than a complete timestamp, use the ISO 8601 format YYYY-MM-DD . This means the full year, month with leading zero, and day with leading zero, seperated by hyphens. December 24th, 2049 1 2 3 { \"date\" : \"2049-12-24\" } January 2nd, 2049 1 2 3 { \"date\" : \"2049-01-02\" } If only the month is required, you may omit the day. In this case, always use the full year, and do not omit the hyphens to avoid confusion with the YYMMDD format. February, 2049 1 2 3 { \"date\" : \"2049-02\" } Timestamps \u00b6 Timestamps must be in ISO 8601 format in UTC, also known as Zulu time, which is denoted with a trailing 'Z'. As with dates above, hours, minutes, and seconds must use leading zeros. All times must use a 24 hour clock (military time). December 12th, 2049, at 3:09 PM 1 2 3 { \"startTime\" : \"2049-12-24T15::09::00Z\" } Avoiding offset & time zone errors \u00b6 Use UTC time. It can be tempting to localize timestamps using offsets. For example, an API could return appointment times in the time zone of the facility's location. There are several issues with this example. Offsets do not represent time zones. A time zone's offset can change with daylight savings time. End users may live in another time zone from the facility they visit. A VA system in another time zone may schedule a facility's appointments. Also, 13 states have more than one time zone. UTC time has no offset and does not implement daylight savings time. Let your API be the source of truth for time and leave the local formatting up to the consuming application. If you do need to capture or return the time zone for an event, use an additional field with a value of the full qualified name in the tz database . An example would be America/Los_Angeles . Duration \u00b6 Durations represent an amount of time, in the format P[n]Y[n]M[n]DT[n]H[n]M[n]S , where: P is the duration designator (for period) placed at the start of the duration representation. - Y is the year designator that follows the value for the number of calendar years. - M is the month designator that follows the value for the number of calendar months. - W is the week designator that follows the value for the number of weeks. - D is the day designator that follows the value for the number of calendar days. T is the time designator that precedes the time components of the representation. - H is the hour designator that follows the value for the number of hours. - M is the minute designator that follows the value for the number of minutes. - S is the second designator that follows the value for the number of seconds. You do not need to include all the duration and time designators. Three years, six months, four days, twelve hours, thirty minutes, and five seconds 1 2 3 { \"duration\" : \"P3Y6M4DT12H30M5S\" } Three years, six months 1 2 3 { \"duration\" : \"P3Y6M\" } Three years 1 2 3 { \"duration\" : \"P3Y\" } Intervals \u00b6 Intervals represent a range of time with specific start and end dates. 1 2 3 { \"interval\" : \"2049-03-01T13:00:00Z/2049-05-11T15:30:00Z\" }","title":"Dates"},{"location":"naming-and-formatting/dates/#dates-time","text":"Requirement Dates and timestamps must follow the ISO 8601 standard . Guidance Dates and timestamps should be in Coordinated Universal Time (UTC) . Timestamps should NOT use offsets . Durations should follow the ISO 8601 standard . Time Intervals should follow the ISO 8601 standard .","title":"Dates &amp; Time"},{"location":"naming-and-formatting/dates/#dates","text":"If your field only needs a date rather than a complete timestamp, use the ISO 8601 format YYYY-MM-DD . This means the full year, month with leading zero, and day with leading zero, seperated by hyphens. December 24th, 2049 1 2 3 { \"date\" : \"2049-12-24\" } January 2nd, 2049 1 2 3 { \"date\" : \"2049-01-02\" } If only the month is required, you may omit the day. In this case, always use the full year, and do not omit the hyphens to avoid confusion with the YYMMDD format. February, 2049 1 2 3 { \"date\" : \"2049-02\" }","title":"Dates"},{"location":"naming-and-formatting/dates/#timestamps","text":"Timestamps must be in ISO 8601 format in UTC, also known as Zulu time, which is denoted with a trailing 'Z'. As with dates above, hours, minutes, and seconds must use leading zeros. All times must use a 24 hour clock (military time). December 12th, 2049, at 3:09 PM 1 2 3 { \"startTime\" : \"2049-12-24T15::09::00Z\" }","title":"Timestamps"},{"location":"naming-and-formatting/dates/#avoiding-offset-time-zone-errors","text":"Use UTC time. It can be tempting to localize timestamps using offsets. For example, an API could return appointment times in the time zone of the facility's location. There are several issues with this example. Offsets do not represent time zones. A time zone's offset can change with daylight savings time. End users may live in another time zone from the facility they visit. A VA system in another time zone may schedule a facility's appointments. Also, 13 states have more than one time zone. UTC time has no offset and does not implement daylight savings time. Let your API be the source of truth for time and leave the local formatting up to the consuming application. If you do need to capture or return the time zone for an event, use an additional field with a value of the full qualified name in the tz database . An example would be America/Los_Angeles .","title":"Avoiding offset &amp; time zone errors"},{"location":"naming-and-formatting/dates/#duration","text":"Durations represent an amount of time, in the format P[n]Y[n]M[n]DT[n]H[n]M[n]S , where: P is the duration designator (for period) placed at the start of the duration representation. - Y is the year designator that follows the value for the number of calendar years. - M is the month designator that follows the value for the number of calendar months. - W is the week designator that follows the value for the number of weeks. - D is the day designator that follows the value for the number of calendar days. T is the time designator that precedes the time components of the representation. - H is the hour designator that follows the value for the number of hours. - M is the minute designator that follows the value for the number of minutes. - S is the second designator that follows the value for the number of seconds. You do not need to include all the duration and time designators. Three years, six months, four days, twelve hours, thirty minutes, and five seconds 1 2 3 { \"duration\" : \"P3Y6M4DT12H30M5S\" } Three years, six months 1 2 3 { \"duration\" : \"P3Y6M\" } Three years 1 2 3 { \"duration\" : \"P3Y\" }","title":"Duration"},{"location":"naming-and-formatting/dates/#intervals","text":"Intervals represent a range of time with specific start and end dates. 1 2 3 { \"interval\" : \"2049-03-01T13:00:00Z/2049-05-11T15:30:00Z\" }","title":"Intervals"},{"location":"naming-and-formatting/standard-field-names/","text":"Standard Field Names \u00b6 Providers are free to name fields as they see fit; however, to promote consistency across APIs, consider using names from the table below for fields with concepts similar to your own. Name Type Description icn string A Master Person Index (MPI) Integration Control Number birlsId string Beneficiary Identification and Records Locator (Sub)System Identifier edipi string A Department of Defense (DoD) Electronic Data Interchange Personal Identifier mhvId string My HealtheVet Identifier secId string EAuth Universally Unique Identifier vet360Id string A VA Profile Vet360 Identifier createDate datetime The datetime a resource was created updateDate datetime The datetime a resource was updated deleteDate datetime The datetime a resource was (soft) deleted startDate datetime The beginning of a datetime range endDate datetime The end of a datetime range page integer The current paginated page pageSize integer The number of items in a paginated page totalSize integer The total of number of items regardless of pagination first string The first page of a paginated list last string The last page of a paginated list prev string The previous page of a paginated list next string The next page of a paginated list filter string How a list is filtered (for example, filter=createDate>2012-08-17T21:51:08Z) sort string How a list is sorted (for example, sort=age,name)","title":"Standard Field Names"},{"location":"naming-and-formatting/standard-field-names/#standard-field-names","text":"Providers are free to name fields as they see fit; however, to promote consistency across APIs, consider using names from the table below for fields with concepts similar to your own. Name Type Description icn string A Master Person Index (MPI) Integration Control Number birlsId string Beneficiary Identification and Records Locator (Sub)System Identifier edipi string A Department of Defense (DoD) Electronic Data Interchange Personal Identifier mhvId string My HealtheVet Identifier secId string EAuth Universally Unique Identifier vet360Id string A VA Profile Vet360 Identifier createDate datetime The datetime a resource was created updateDate datetime The datetime a resource was updated deleteDate datetime The datetime a resource was (soft) deleted startDate datetime The beginning of a datetime range endDate datetime The end of a datetime range page integer The current paginated page pageSize integer The number of items in a paginated page totalSize integer The total of number of items regardless of pagination first string The first page of a paginated list last string The last page of a paginated list prev string The previous page of a paginated list next string The next page of a paginated list filter string How a list is filtered (for example, filter=createDate>2012-08-17T21:51:08Z) sort string How a list is sorted (for example, sort=age,name)","title":"Standard Field Names"},{"location":"paths-and-operations/create/","text":"Create (POST) \u00b6 Requirement Endpoints must use the POST method when creating resources without a consumer-supplied ID. The operation should return a 201 with the created resource reflected in the response body. Guidance POST should not be idempotent; meaning, if the request is sent again, a second resource should be created. The operation should return the created resource inside a data object. The operation should return any errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation). In most cases, the service generates an identifier for the resource. In cases where an identifier is supplied by the API consumer, follow the guidance for creating a resource with a consumer supplied identifier . Example request \u00b6 POST ../rx/v0/prescriptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true }, } } Example response \u00b6 For returning a 201 Created HTTP status code, the response body would confirm the resource had been created as shown below (in JSON::API format). 201 Created 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"data\" : { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } } Example error \u00b6 422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] } Create with a consumer-supplied identifier \u00b6 Creating resources works differently when the consumer is supplying the identifier versus when the system is generating the identifier upon creation. Guidance A PUT method should be used, as the operation is idempotent even during creation. On successful creation a 201 should be returned with the created resource in the body. If the result is an update of an existing resource, a 204 should be returned with no response body. The operation should return any errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation).","title":"Create"},{"location":"paths-and-operations/create/#create-post","text":"Requirement Endpoints must use the POST method when creating resources without a consumer-supplied ID. The operation should return a 201 with the created resource reflected in the response body. Guidance POST should not be idempotent; meaning, if the request is sent again, a second resource should be created. The operation should return the created resource inside a data object. The operation should return any errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation). In most cases, the service generates an identifier for the resource. In cases where an identifier is supplied by the API consumer, follow the guidance for creating a resource with a consumer supplied identifier .","title":"Create (POST)"},{"location":"paths-and-operations/create/#example-request","text":"POST ../rx/v0/prescriptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true }, } }","title":"Example request"},{"location":"paths-and-operations/create/#example-response","text":"For returning a 201 Created HTTP status code, the response body would confirm the resource had been created as shown below (in JSON::API format). 201 Created 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"data\" : { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } }","title":"Example response"},{"location":"paths-and-operations/create/#example-error","text":"422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] }","title":"Example error"},{"location":"paths-and-operations/create/#create-with-a-consumer-supplied-identifier","text":"Creating resources works differently when the consumer is supplying the identifier versus when the system is generating the identifier upon creation. Guidance A PUT method should be used, as the operation is idempotent even during creation. On successful creation a 201 should be returned with the created resource in the body. If the result is an update of an existing resource, a 204 should be returned with no response body. The operation should return any errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation).","title":"Create with a consumer-supplied identifier"},{"location":"paths-and-operations/custom-operations/","text":"Custom Operations \u00b6 Requirement If the HTTP method chosen for the custom operation does not accept a request body ( GET or DELETE ), the operation must not send one. Guidance Providers should show that a custom operation was intentional by ending the path with a verb. Custom operations with body parameters should default to the POST method. Custom operations should not use the PATCH method. Providers should choose from the 5 standard HTTP methods whenever workable, using custom operations only for custom functionality that falls outside of the uses of one of the standard methods. Example using GET \u00b6 In this example of getting tracking information for a prescription, the request does not need to send any parameters. Therefore, a GET method is preferred as it is the standard REST method for reading a resource. Example response \u00b6 POST .../rx/v1/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967/track 1 // No reques t body Example response \u00b6 200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"data\" : { \"type\" : \"PrescriptionTracking\" , \"id\" : \"add84f99-f9ce-48f8-a56c-625868d11efc\" , \"attributes\" : { \"prescriptionId\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"trackingNumber\" : \"add84f99-f9ce-48f8-a56c-625868d11efc\" , \"shippedDate\" : \"2049-07-22\" \"deliveryDervice\" : \"USPS\" \"trackingURL\" : \"https://tools.usps.com/go/TrackConfirmAction?tRef=fullpage&tLc=2&text28777=&tLabels=add84f99-f9ce-48f8-a56c-625868d11efc%2C&tABt=false\" } } } Example using POST \u00b6 In this example, which contains (mock) PII, we're sending a prescription search query that includes a mock SSN number in a POST body. The request side of the operation uses a custom Query resource that is not persisted in the system and can not be retrieved. However, the operation returns a response that would look almost identical to a Prescription resource collection's read operation. Example request \u00b6 POST .../rx/v1/prescriptions/search 1 2 3 4 5 6 7 8 9 { \"data\" : { \"type\" : \"Query\" , \"attributes\" : { \"ssn\" : \"777-98-7654\" , \"quantity\" : \">10\" , \"dispensedDate\" : \">2049-01-01T00:00:00Z AND <2050-01-01T00:00:00Z\" } } Example response \u00b6 200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"data\" : [ { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } }, { \"type\" : \"Prescription\" , \"id\" : \"ac9d4b3f-e4bd-49dd-b794-64ad05480729\" , \"attributes\" : { \"prescriptionNumber\" : \"1239832\" , \"prescriptionName\" : \"ACETAMINOPHEN 200MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-22T11:23:00Z\" , \"expirationDate\" : \"2050-07-22T11:30:00Z\" , \"dispensedDate\" : \"2049-07-23T012:35:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } ] }","title":"Custom Operations"},{"location":"paths-and-operations/custom-operations/#custom-operations","text":"Requirement If the HTTP method chosen for the custom operation does not accept a request body ( GET or DELETE ), the operation must not send one. Guidance Providers should show that a custom operation was intentional by ending the path with a verb. Custom operations with body parameters should default to the POST method. Custom operations should not use the PATCH method. Providers should choose from the 5 standard HTTP methods whenever workable, using custom operations only for custom functionality that falls outside of the uses of one of the standard methods.","title":"Custom Operations"},{"location":"paths-and-operations/custom-operations/#example-using-get","text":"In this example of getting tracking information for a prescription, the request does not need to send any parameters. Therefore, a GET method is preferred as it is the standard REST method for reading a resource.","title":"Example using GET"},{"location":"paths-and-operations/custom-operations/#example-response","text":"POST .../rx/v1/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967/track 1 // No reques t body","title":"Example response"},{"location":"paths-and-operations/custom-operations/#example-response_1","text":"200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"data\" : { \"type\" : \"PrescriptionTracking\" , \"id\" : \"add84f99-f9ce-48f8-a56c-625868d11efc\" , \"attributes\" : { \"prescriptionId\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"trackingNumber\" : \"add84f99-f9ce-48f8-a56c-625868d11efc\" , \"shippedDate\" : \"2049-07-22\" \"deliveryDervice\" : \"USPS\" \"trackingURL\" : \"https://tools.usps.com/go/TrackConfirmAction?tRef=fullpage&tLc=2&text28777=&tLabels=add84f99-f9ce-48f8-a56c-625868d11efc%2C&tABt=false\" } } }","title":"Example response"},{"location":"paths-and-operations/custom-operations/#example-using-post","text":"In this example, which contains (mock) PII, we're sending a prescription search query that includes a mock SSN number in a POST body. The request side of the operation uses a custom Query resource that is not persisted in the system and can not be retrieved. However, the operation returns a response that would look almost identical to a Prescription resource collection's read operation.","title":"Example using POST"},{"location":"paths-and-operations/custom-operations/#example-request","text":"POST .../rx/v1/prescriptions/search 1 2 3 4 5 6 7 8 9 { \"data\" : { \"type\" : \"Query\" , \"attributes\" : { \"ssn\" : \"777-98-7654\" , \"quantity\" : \">10\" , \"dispensedDate\" : \">2049-01-01T00:00:00Z AND <2050-01-01T00:00:00Z\" } }","title":"Example request"},{"location":"paths-and-operations/custom-operations/#example-response_2","text":"200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"data\" : [ { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } }, { \"type\" : \"Prescription\" , \"id\" : \"ac9d4b3f-e4bd-49dd-b794-64ad05480729\" , \"attributes\" : { \"prescriptionNumber\" : \"1239832\" , \"prescriptionName\" : \"ACETAMINOPHEN 200MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-22T11:23:00Z\" , \"expirationDate\" : \"2050-07-22T11:30:00Z\" , \"dispensedDate\" : \"2049-07-23T012:35:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } ] }","title":"Example response"},{"location":"paths-and-operations/destroy/","text":"Destroy (DELETE) \u00b6 Requirement The operation must use the DELETE method when detroying resources. The operation must not include a request body. The operation should return any errors inside an errors object. The operation must return a 404 status code if the resource can't be found. Guidance Success operations that include a status in the body should return a 200 status code. Success operations that do not include a status in the body should return a 204 status code. Example request \u00b6 DELETE ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 // No reques t body Example response \u00b6 204 No Content 1 // No respo nse body","title":"Destroy"},{"location":"paths-and-operations/destroy/#destroy-delete","text":"Requirement The operation must use the DELETE method when detroying resources. The operation must not include a request body. The operation should return any errors inside an errors object. The operation must return a 404 status code if the resource can't be found. Guidance Success operations that include a status in the body should return a 200 status code. Success operations that do not include a status in the body should return a 204 status code.","title":"Destroy (DELETE)"},{"location":"paths-and-operations/destroy/#example-request","text":"DELETE ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 // No reques t body","title":"Example request"},{"location":"paths-and-operations/destroy/#example-response","text":"204 No Content 1 // No respo nse body","title":"Example response"},{"location":"paths-and-operations/errors/","text":"Errors \u00b6 Guidance Error fields should follow RFC 7807 An operation should be able to return multiple errors in one response. The status field should match the HTTP status code being returned. The title field should be the generic class of the error and consistent across the API. The detail field should be specific to the error at hand. If an error is in the request, a source field should point to it. Error Schemas \u00b6 The error schema should match that of the information model you are using. This guide recommends using JSON::API unless an industry-specific format like FHIR is required. We recommend JSON::API because it has a well thought-out, extensible, and relatively simple error model. An example of a JSON::API-formatted 422 'Unprocessable Entity' error is: 422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] } FHIR has a different error schema (OperationOutcome resource) . An example is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"resourceType\" : \"OperationOutcome\" , \"id\" : \"searchfail\" , \"text\" : { \"status\" : \"generated\" , \"div\" : \"<div xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n<p>The &quot;name&quot; parameter has the modifier &quot;exact&quot; which is not supported by this server</p>\\n</div>\" }, \"issue\" : [ { \"severity\" : \"fatal\" , \"code\" : \"code-invalid\" , \"details\" : { \"text\" : \"The \\\"name\\\" parameter has the modifier \\\"exact\\\" which is not supported by this server\" }, \"location\" : [ \"http.name:exact\" ] } ] } Multiple errors \u00b6 Operations should be able to return multiple errors and providers should return errors for all the issues with the request at once. For example, if 2 fields are invalid, return both so the consumer is aware of all the issues that must be corrected, instead of raising an error once the first invalid field is processed. If the error statuses are different but have the same hundredth, for example, both are 4xx , return the base generic value ( 400 ). If the errors have mixed hundredth values return a 500 . 422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" }, { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/contactEmail\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"contactEmail must be a valid email address.\" } ] } Choosing an error code \u00b6 Choosing the correct HTTP status code for an error can be confusing. With VA APIs, the error will originate from one of three sources: from the consumer\u2019s request; an upstream service the API depends on; or the API itself, such as the web application and its components. Request errors: Issues caused by requests are a flavor of a 400 error ( 4xx ). Upstream errors: Errors from upstream services are 502 , 503 , or 504 . Application errors: Always return a 500 . The Lighthouse gateway will handle some of these errors for you. Within the 4xx range, the gateway handles the authorization and authentication errors ( 401 and 403 ) as well as the rate limiting errors ( 429 ). The gateway will also handle your service being unavailable ( 503 ) or failing to respond to a request in time ( 504 ). The flowchart below can help you decide which HTTP status code to return for an error.","title":"Errors"},{"location":"paths-and-operations/errors/#errors","text":"Guidance Error fields should follow RFC 7807 An operation should be able to return multiple errors in one response. The status field should match the HTTP status code being returned. The title field should be the generic class of the error and consistent across the API. The detail field should be specific to the error at hand. If an error is in the request, a source field should point to it.","title":"Errors"},{"location":"paths-and-operations/errors/#error-schemas","text":"The error schema should match that of the information model you are using. This guide recommends using JSON::API unless an industry-specific format like FHIR is required. We recommend JSON::API because it has a well thought-out, extensible, and relatively simple error model. An example of a JSON::API-formatted 422 'Unprocessable Entity' error is: 422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] } FHIR has a different error schema (OperationOutcome resource) . An example is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"resourceType\" : \"OperationOutcome\" , \"id\" : \"searchfail\" , \"text\" : { \"status\" : \"generated\" , \"div\" : \"<div xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n<p>The &quot;name&quot; parameter has the modifier &quot;exact&quot; which is not supported by this server</p>\\n</div>\" }, \"issue\" : [ { \"severity\" : \"fatal\" , \"code\" : \"code-invalid\" , \"details\" : { \"text\" : \"The \\\"name\\\" parameter has the modifier \\\"exact\\\" which is not supported by this server\" }, \"location\" : [ \"http.name:exact\" ] } ] }","title":"Error Schemas"},{"location":"paths-and-operations/errors/#multiple-errors","text":"Operations should be able to return multiple errors and providers should return errors for all the issues with the request at once. For example, if 2 fields are invalid, return both so the consumer is aware of all the issues that must be corrected, instead of raising an error once the first invalid field is processed. If the error statuses are different but have the same hundredth, for example, both are 4xx , return the base generic value ( 400 ). If the errors have mixed hundredth values return a 500 . 422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" }, { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/contactEmail\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"contactEmail must be a valid email address.\" } ] }","title":"Multiple errors"},{"location":"paths-and-operations/errors/#choosing-an-error-code","text":"Choosing the correct HTTP status code for an error can be confusing. With VA APIs, the error will originate from one of three sources: from the consumer\u2019s request; an upstream service the API depends on; or the API itself, such as the web application and its components. Request errors: Issues caused by requests are a flavor of a 400 error ( 4xx ). Upstream errors: Errors from upstream services are 502 , 503 , or 504 . Application errors: Always return a 500 . The Lighthouse gateway will handle some of these errors for you. Within the 4xx range, the gateway handles the authorization and authentication errors ( 401 and 403 ) as well as the rate limiting errors ( 429 ). The gateway will also handle your service being unavailable ( 503 ) or failing to respond to a request in time ( 504 ). The flowchart below can help you decide which HTTP status code to return for an error.","title":"Choosing an error code"},{"location":"paths-and-operations/headers/","text":"Headers \u00b6 The purpose of HTTP headers is to provide metadata information about the body or the sender of the message in a uniform, standardized, and isolated way. Requirement Header names must be case insensitive. Headers must not include API or domain-specific values. APIs must not use headers in a way that changes the behaviour of HTTP methods. APIs must not use headers to communicate business logic or service logic (such as paging response info or PII query parameters) Guidance HTTP headers should only be used for the purpose of handling cross-cutting concerns such as authorization. API implementations should not introduce or depend on headers. If available, HTTP standard headers should be used instead of creating a custom header. Accept \u00b6 This request header specifies the media types that the API client is capable of handling in the response. These API guidelines assume that APIs accept application/json . Guidance APIs handling the request should not assume Accept is available. Accept-Charset \u00b6 Requirement APIs must not respond to this header. Browsers omit this header and servers should ignore it. Content-Language \u00b6 This request/response header is used to specify the language of the content. Guidance APIs should provide this header in the response. This value of this header should correspond to the language of the data in the response. APIs should default to using the locale en-US . Example: 1 Content-Language: en-US Content-Type \u00b6 This request/response header indicates the media type of the request or response body. Requirement APIs must include it with response if there is a response body (it is not used with 204 responses). If the content is a text-based type, such as application/json , the Content-Type must include a character-set parameter. The character-set must be UTF-8 . In a request: 1 Accept: application/json; Accept-Charset: utf-8 In a response: 1 Content-Type: application/json; charset=utf-8 Link \u00b6 According to Web Linking RFC 5988 , a link is a typed connection between two resources that are identified by Internationalised Resource Identifiers (IRIs). The Link entity-header field provides a means for serializing one or more links in HTTP headers. Requirement The Link header must not be used in responses with status codes 201 or 3xx . Guidance APIs should prefer returning links within the response body's meta object. Location \u00b6 The Location response header indicates the URL to redirect a page to. It only provides a meaning when served with a 3xx (redirection) or 201 (created) status response. Requirement The Location header must only be used in responses with redirection status codes 3xx or 201 created. Prefer \u00b6 The Prefer request header field is used to indicate that a particular server behavior(s) is preferred by the client but is not required for successful completion of the request. It is an end-to-end field and must be forwarded by a proxy if the request is forwarded unless Prefer is explicitly identified as being hop-by-hop using the Connection header field. The following token values are possible to use for APIs as long as an API's documentation explicitly indicates support for Prefer . Prefer: respond-async : API client prefers that the API server processes its request asynchronously. Server returns a 202 Accepted response and processes the request asynchronously. API server could use a webhook to inform the client subsequently, or the client may call GET to get the response at a later time. Prefer: read-consistent : API client prefers that the API server returns responses from a durable store with consistent data. For APIs that are not offering any optimization preferences for their clients, this behavior would be the default and it would not require the client to set this token. Prefer: read-eventual-consistent : API client prefers that the API server returns responses from cache or eventually consistent datastore if applicable. If there is a miss in finding the data from either of these two types of sources, the API server might return response from a consistent, durable datastore. Prefer: read-cache : API client prefers that the API server returns responses from cache if available. If the cache hit is a miss, the server could return the response from other sources such as eventual consistent datastore or a consistent, durable datastore. Prefer: return=representation : API client prefers that the API server includes an entity representing the current state of the resource in the response to a successful request. This preference is intended to provide a means of optimizing communication between the client and server. It eliminates the need for a subsequent GET request to retrieve the current representation of the resource after a creation (POST) modification operation (PUT or PATCH). Prefer: return=minimal : API client indicates that the server returns only a minimal response to a successful request. The determination of what constitutes an appropriate \u201cminimal\u201d response is solely at the discretion of the server. ETag \u00b6 An entity tag (ETag) response header is a good approach to make update requests idempotent. ETags are generated by the server based on the current resource representation. If-Match \u00b6 Using the If-Match header with the current ETag value representing the current resource state allows the server to provide idempotent operations and avoid race conditions. The server would only execute the update if the If-Match value matches current ETag for the resource.","title":"Headers"},{"location":"paths-and-operations/headers/#headers","text":"The purpose of HTTP headers is to provide metadata information about the body or the sender of the message in a uniform, standardized, and isolated way. Requirement Header names must be case insensitive. Headers must not include API or domain-specific values. APIs must not use headers in a way that changes the behaviour of HTTP methods. APIs must not use headers to communicate business logic or service logic (such as paging response info or PII query parameters) Guidance HTTP headers should only be used for the purpose of handling cross-cutting concerns such as authorization. API implementations should not introduce or depend on headers. If available, HTTP standard headers should be used instead of creating a custom header.","title":"Headers"},{"location":"paths-and-operations/headers/#accept","text":"This request header specifies the media types that the API client is capable of handling in the response. These API guidelines assume that APIs accept application/json . Guidance APIs handling the request should not assume Accept is available.","title":"Accept"},{"location":"paths-and-operations/headers/#accept-charset","text":"Requirement APIs must not respond to this header. Browsers omit this header and servers should ignore it.","title":"Accept-Charset"},{"location":"paths-and-operations/headers/#content-language","text":"This request/response header is used to specify the language of the content. Guidance APIs should provide this header in the response. This value of this header should correspond to the language of the data in the response. APIs should default to using the locale en-US . Example: 1 Content-Language: en-US","title":"Content-Language"},{"location":"paths-and-operations/headers/#content-type","text":"This request/response header indicates the media type of the request or response body. Requirement APIs must include it with response if there is a response body (it is not used with 204 responses). If the content is a text-based type, such as application/json , the Content-Type must include a character-set parameter. The character-set must be UTF-8 . In a request: 1 Accept: application/json; Accept-Charset: utf-8 In a response: 1 Content-Type: application/json; charset=utf-8","title":"Content-Type"},{"location":"paths-and-operations/headers/#link","text":"According to Web Linking RFC 5988 , a link is a typed connection between two resources that are identified by Internationalised Resource Identifiers (IRIs). The Link entity-header field provides a means for serializing one or more links in HTTP headers. Requirement The Link header must not be used in responses with status codes 201 or 3xx . Guidance APIs should prefer returning links within the response body's meta object.","title":"Link"},{"location":"paths-and-operations/headers/#location","text":"The Location response header indicates the URL to redirect a page to. It only provides a meaning when served with a 3xx (redirection) or 201 (created) status response. Requirement The Location header must only be used in responses with redirection status codes 3xx or 201 created.","title":"Location"},{"location":"paths-and-operations/headers/#prefer","text":"The Prefer request header field is used to indicate that a particular server behavior(s) is preferred by the client but is not required for successful completion of the request. It is an end-to-end field and must be forwarded by a proxy if the request is forwarded unless Prefer is explicitly identified as being hop-by-hop using the Connection header field. The following token values are possible to use for APIs as long as an API's documentation explicitly indicates support for Prefer . Prefer: respond-async : API client prefers that the API server processes its request asynchronously. Server returns a 202 Accepted response and processes the request asynchronously. API server could use a webhook to inform the client subsequently, or the client may call GET to get the response at a later time. Prefer: read-consistent : API client prefers that the API server returns responses from a durable store with consistent data. For APIs that are not offering any optimization preferences for their clients, this behavior would be the default and it would not require the client to set this token. Prefer: read-eventual-consistent : API client prefers that the API server returns responses from cache or eventually consistent datastore if applicable. If there is a miss in finding the data from either of these two types of sources, the API server might return response from a consistent, durable datastore. Prefer: read-cache : API client prefers that the API server returns responses from cache if available. If the cache hit is a miss, the server could return the response from other sources such as eventual consistent datastore or a consistent, durable datastore. Prefer: return=representation : API client prefers that the API server includes an entity representing the current state of the resource in the response to a successful request. This preference is intended to provide a means of optimizing communication between the client and server. It eliminates the need for a subsequent GET request to retrieve the current representation of the resource after a creation (POST) modification operation (PUT or PATCH). Prefer: return=minimal : API client indicates that the server returns only a minimal response to a successful request. The determination of what constitutes an appropriate \u201cminimal\u201d response is solely at the discretion of the server.","title":"Prefer"},{"location":"paths-and-operations/headers/#etag","text":"An entity tag (ETag) response header is a good approach to make update requests idempotent. ETags are generated by the server based on the current resource representation.","title":"ETag"},{"location":"paths-and-operations/headers/#if-match","text":"Using the If-Match header with the current ETag value representing the current resource state allows the server to provide idempotent operations and avoid race conditions. The server would only execute the update if the If-Match value matches current ETag for the resource.","title":"If-Match"},{"location":"paths-and-operations/paths/","text":"Paths \u00b6 Requirement Full URIs must follow RFC 3986 . Base (server) URLs must not have a trailing slash. Base (server) URLs must be relative to their public facing URLs on Lighthouse. Paths must use dashes rather than underscores for spaces in words. An example URI for a fictional 'Rx' API that follows the RFC 3986 standard is: 1 GET https://api.va.gov/services/rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953 How this guide, and the OpenAPI spec, refers to parts of a URI differs slightly from that RFC. Following OpenAPI naming conventions the URI above is split into the following parts: 'https://api.va.gov/rx/v1' is the base URL found in the \"servers\" section of the OAS. 'https' is the scheme. 'api.va.gov' is the authority. 'rx' is the namespace. 'v1' is the version. 'prescriptions' is the operation path. '42ceca25-e9d0-466f-84a8-8ce554d70953' is the resource identifier. 'GET' is the operation or method. Namespaces \u00b6 Guidance Namespaces should match the product name of the API as closely as possible. Namespaces should remain consistent between versions. Namespaces should not reflect internal VA organizational and communication structures. Namespaces should not be more than 2 levels deep. Namespaces should not include application names ('WebSphere') or environments ('PROD'). Take care in choosing a namespace. This is the name of your API and should not change version to version. The namespace of your API is part of your product branding and should be user, rather than provider, centered. Choose a namespace that matches as closely as possible the product name of the API in the OAS documentation. Operation paths \u00b6 While everything after the namespace is technically still part of the path in URI terms, for APIs--and specifically those that follow the OpenAPI spec--paths are pointers to resource operations within a version. The OpenAPI spec says: In OpenAPI terms, paths are endpoints (resources), such as /users or /reports/summary/, that your API exposes, and operations are the HTTP methods used to manipulate these paths, such as GET, POST or DELETE. Resources will inform how you construct your paths. Most of your paths will revolve around returning a collection of resources , and performing Create, Read, Update, and Destroy (CRUD) operations on singular resources . Note that REST and CRUD are not synonymous. An API can be RESTful without CRUD operations. If an operation does not fall under the CRUD resource operations, we consider it \u2018 Non-Resourceful \u2019 and the naming of its path requires special care. Collection resources \u00b6 Guidance Providers should use plural nouns for collections. Collections represent a list of resources. We prefer plural nouns with no identifier in the URL path. The Read section of this guide has details on crafting requests and responses for collections. 1 GET ../rx/v1/prescriptions Use query parameters to customize the returned collection, such as for pagination. An example is: 1 GET ../rx/v1/prescriptions?page=2&pageSize=10 Singular resources \u00b6 Guidance Resources should NOT be identified using easily guessable sequential numbers. APIs should use a UUID as a resource identifier, as outlined in RFC 4122 . Identifiers should be in the form 8-4-4-4-12 with 36 total characters (32 hexadecimal characters and 4 hyphens). These represent a single instance of a resource in a collection. They should be completely and uniquely identified on the URL path. The UUID \u201842ceca25-e9d0-466f-84a8-8ce554d70953\u2019 uniquely identifying a claim 1 GET ../rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953 Sub-resources \u00b6 Guidance Sub-resources should be appended after the parent's identifier. When called with no sub-resource identifier, an API should return all the sub-resources. Sub-resource in paths more than 2 levels deep are not recommended . Below is an example of a one-to-many resource relationship, showing a prescription with many refill sub-resources. To return all the refills for the prescription with id \u201842ceca25-e9d0-466f-84a8-8ce554d70953\u2019, use: 1 GET ../rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953/documents Then to return a single sub-resource, in this case the refill with id \u20182b0f2b18-a476-4e13-a4e0-b2fb8f499ae4\u2019, use: 1 GET ../rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953/refills/2b0f2b18-a476-4e13-a4e0-b2fb8f499ae4 Paths for custom operations \u00b6 Guidance Providers should show that a custom operation was intentional by ending the path with a verb. There may be considerations that force us into a non-standard path. For example, you may decide to support searching of resources using POST rather than GET. This may be because a lengthy query would exceed the server\u2019s limit (often 1024 and 2048 characters, for query strings, and URLs respectively), or for security reasons to avoid PII or PHI showing up in logged URLs. In cases like these, use a verb rather than a noun for the custom operation . 1 POST .../rx/v 1 /prescrip t io ns /search","title":"Paths"},{"location":"paths-and-operations/paths/#paths","text":"Requirement Full URIs must follow RFC 3986 . Base (server) URLs must not have a trailing slash. Base (server) URLs must be relative to their public facing URLs on Lighthouse. Paths must use dashes rather than underscores for spaces in words. An example URI for a fictional 'Rx' API that follows the RFC 3986 standard is: 1 GET https://api.va.gov/services/rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953 How this guide, and the OpenAPI spec, refers to parts of a URI differs slightly from that RFC. Following OpenAPI naming conventions the URI above is split into the following parts: 'https://api.va.gov/rx/v1' is the base URL found in the \"servers\" section of the OAS. 'https' is the scheme. 'api.va.gov' is the authority. 'rx' is the namespace. 'v1' is the version. 'prescriptions' is the operation path. '42ceca25-e9d0-466f-84a8-8ce554d70953' is the resource identifier. 'GET' is the operation or method.","title":"Paths"},{"location":"paths-and-operations/paths/#namespaces","text":"Guidance Namespaces should match the product name of the API as closely as possible. Namespaces should remain consistent between versions. Namespaces should not reflect internal VA organizational and communication structures. Namespaces should not be more than 2 levels deep. Namespaces should not include application names ('WebSphere') or environments ('PROD'). Take care in choosing a namespace. This is the name of your API and should not change version to version. The namespace of your API is part of your product branding and should be user, rather than provider, centered. Choose a namespace that matches as closely as possible the product name of the API in the OAS documentation.","title":"Namespaces"},{"location":"paths-and-operations/paths/#operation-paths","text":"While everything after the namespace is technically still part of the path in URI terms, for APIs--and specifically those that follow the OpenAPI spec--paths are pointers to resource operations within a version. The OpenAPI spec says: In OpenAPI terms, paths are endpoints (resources), such as /users or /reports/summary/, that your API exposes, and operations are the HTTP methods used to manipulate these paths, such as GET, POST or DELETE. Resources will inform how you construct your paths. Most of your paths will revolve around returning a collection of resources , and performing Create, Read, Update, and Destroy (CRUD) operations on singular resources . Note that REST and CRUD are not synonymous. An API can be RESTful without CRUD operations. If an operation does not fall under the CRUD resource operations, we consider it \u2018 Non-Resourceful \u2019 and the naming of its path requires special care.","title":"Operation paths"},{"location":"paths-and-operations/paths/#collection-resources","text":"Guidance Providers should use plural nouns for collections. Collections represent a list of resources. We prefer plural nouns with no identifier in the URL path. The Read section of this guide has details on crafting requests and responses for collections. 1 GET ../rx/v1/prescriptions Use query parameters to customize the returned collection, such as for pagination. An example is: 1 GET ../rx/v1/prescriptions?page=2&pageSize=10","title":"Collection resources"},{"location":"paths-and-operations/paths/#singular-resources","text":"Guidance Resources should NOT be identified using easily guessable sequential numbers. APIs should use a UUID as a resource identifier, as outlined in RFC 4122 . Identifiers should be in the form 8-4-4-4-12 with 36 total characters (32 hexadecimal characters and 4 hyphens). These represent a single instance of a resource in a collection. They should be completely and uniquely identified on the URL path. The UUID \u201842ceca25-e9d0-466f-84a8-8ce554d70953\u2019 uniquely identifying a claim 1 GET ../rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953","title":"Singular resources"},{"location":"paths-and-operations/paths/#sub-resources","text":"Guidance Sub-resources should be appended after the parent's identifier. When called with no sub-resource identifier, an API should return all the sub-resources. Sub-resource in paths more than 2 levels deep are not recommended . Below is an example of a one-to-many resource relationship, showing a prescription with many refill sub-resources. To return all the refills for the prescription with id \u201842ceca25-e9d0-466f-84a8-8ce554d70953\u2019, use: 1 GET ../rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953/documents Then to return a single sub-resource, in this case the refill with id \u20182b0f2b18-a476-4e13-a4e0-b2fb8f499ae4\u2019, use: 1 GET ../rx/v1/prescriptions/42ceca25-e9d0-466f-84a8-8ce554d70953/refills/2b0f2b18-a476-4e13-a4e0-b2fb8f499ae4","title":"Sub-resources"},{"location":"paths-and-operations/paths/#paths-for-custom-operations","text":"Guidance Providers should show that a custom operation was intentional by ending the path with a verb. There may be considerations that force us into a non-standard path. For example, you may decide to support searching of resources using POST rather than GET. This may be because a lengthy query would exceed the server\u2019s limit (often 1024 and 2048 characters, for query strings, and URLs respectively), or for security reasons to avoid PII or PHI showing up in logged URLs. In cases like these, use a verb rather than a noun for the custom operation . 1 POST .../rx/v 1 /prescrip t io ns /search","title":"Paths for custom operations"},{"location":"paths-and-operations/read/","text":"Read (GET) \u00b6 Collections \u00b6 Requirement The operation must use an HTTP GET verb when fetching collections. Successful responses must return a 200 status code. An empty list is a successful response and must return a 200 status code. Guidance The operation should return resources inside a data object. The operation should return any errors inside an errors object. Supplemental information, such as pagination, should be in a meta object. A collection resource should return a list of representation of all of the given resources (instances), including any related metadata. An array of resources should be in the items field. Consistent naming of collection resource fields allows API clients to create generic handling for using the provided data across various resource collections. The GET verb should not affect the system, and should not change the response on subsequent requests unless the underlying data changes (as in, it should be idempotent). Exceptions to 'changing the system' are typically instrumentation/logging-related. The list of data should be filtered based on the privileges available to the API client, so that it lists only the resoures for which the client has the authorization to view and not all the resources in the domain. Providing a summarized or minimized version of the data representation can reduce the bandwidth footprint in cases where individual resources contain a large object. Example request \u00b6 GET ../rx/v0/prescriptions 1 // No reques t body Example response \u00b6 200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"data\" : [ { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } }, { \"type\" : \"Prescription\" , \"id\" : \"ac9d4b3f-e4bd-49dd-b794-64ad05480729\" , \"attributes\" : { \"prescriptionNumber\" : \"1239832\" , \"prescriptionName\" : \"ACETAMINOPHEN 200MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-22T11:23:00Z\" , \"expirationDate\" : \"2050-07-22T11:30:00Z\" , \"dispensedDate\" : \"2049-07-23T012:35:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } ] } Single resource \u00b6 Requirement The operation must use a GET verb when fetching single resources. Successful responses must return a 200 status code. The operation must return a 404 status code if the resource can not be found. Guidance The operation should return the resource inside a data object. The operation should return any errors inside an errors object. A single resource is typically derived from the parent collection of resources and is often more detailed than an item in the representation of a collection resource. Executing GET should never affect the system and should not change the response on subsequent requests (as in, it should be idempotent). All identifiers for sensitive data should be non-sequential and preferably non-numeric. In scenarios where this data might be used as a subordinate to other data, immutable string identifiers should be used for easier readability and debugging (such as, NAME_OF_VALUE vs 1421321 ). Example request \u00b6 GET ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 // No reques t body Example response \u00b6 If the resource with that id is found, return a 200 'OK' status code. The response body should include the resource type and id as shown below in JSON::API format. 200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"data\" : { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } } If the resource is not found, return a 404 'Not Found' status code. 404 Not Found 1 2 3 4 5 6 7 8 9 { \"errors\" : [ { \"status\" : \"404\" , \"title\" : \"Not Found\" , \"detail\" : \"The requested resource could not be found.\" } ] }","title":"Read"},{"location":"paths-and-operations/read/#read-get","text":"","title":"Read (GET)"},{"location":"paths-and-operations/read/#collections","text":"Requirement The operation must use an HTTP GET verb when fetching collections. Successful responses must return a 200 status code. An empty list is a successful response and must return a 200 status code. Guidance The operation should return resources inside a data object. The operation should return any errors inside an errors object. Supplemental information, such as pagination, should be in a meta object. A collection resource should return a list of representation of all of the given resources (instances), including any related metadata. An array of resources should be in the items field. Consistent naming of collection resource fields allows API clients to create generic handling for using the provided data across various resource collections. The GET verb should not affect the system, and should not change the response on subsequent requests unless the underlying data changes (as in, it should be idempotent). Exceptions to 'changing the system' are typically instrumentation/logging-related. The list of data should be filtered based on the privileges available to the API client, so that it lists only the resoures for which the client has the authorization to view and not all the resources in the domain. Providing a summarized or minimized version of the data representation can reduce the bandwidth footprint in cases where individual resources contain a large object.","title":"Collections"},{"location":"paths-and-operations/read/#example-request","text":"GET ../rx/v0/prescriptions 1 // No reques t body","title":"Example request"},{"location":"paths-and-operations/read/#example-response","text":"200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"data\" : [ { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } }, { \"type\" : \"Prescription\" , \"id\" : \"ac9d4b3f-e4bd-49dd-b794-64ad05480729\" , \"attributes\" : { \"prescriptionNumber\" : \"1239832\" , \"prescriptionName\" : \"ACETAMINOPHEN 200MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-22T11:23:00Z\" , \"expirationDate\" : \"2050-07-22T11:30:00Z\" , \"dispensedDate\" : \"2049-07-23T012:35:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } ] }","title":"Example response"},{"location":"paths-and-operations/read/#single-resource","text":"Requirement The operation must use a GET verb when fetching single resources. Successful responses must return a 200 status code. The operation must return a 404 status code if the resource can not be found. Guidance The operation should return the resource inside a data object. The operation should return any errors inside an errors object. A single resource is typically derived from the parent collection of resources and is often more detailed than an item in the representation of a collection resource. Executing GET should never affect the system and should not change the response on subsequent requests (as in, it should be idempotent). All identifiers for sensitive data should be non-sequential and preferably non-numeric. In scenarios where this data might be used as a subordinate to other data, immutable string identifiers should be used for easier readability and debugging (such as, NAME_OF_VALUE vs 1421321 ).","title":"Single resource"},{"location":"paths-and-operations/read/#example-request_1","text":"GET ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 // No reques t body","title":"Example request"},{"location":"paths-and-operations/read/#example-response_1","text":"If the resource with that id is found, return a 200 'OK' status code. The response body should include the resource type and id as shown below in JSON::API format. 200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"data\" : { \"type\" : \"Prescription\" , \"id\" : \"1c2dfaaa-4eb9-482e-86a9-4e7274975967\" , \"attributes\" : { \"prescriptionNumber\" : \"1239876\" , \"prescriptionName\" : \"IBUPROFEN 400MG TAB\" , \"facilityName\" : \"DAYT29\" , \"stationNumber\" : \"989\" , \"orderedDate\" : \"2049-07-21T01:39:00Z\" , \"expirationDate\" : \"2050-07-21T01:39:00Z\" , \"dispensedDate\" : \"2049-07-22T010:07:00Z\" , \"quantity\" : 30 , \"isRefillable\" : true } } } If the resource is not found, return a 404 'Not Found' status code. 404 Not Found 1 2 3 4 5 6 7 8 9 { \"errors\" : [ { \"status\" : \"404\" , \"title\" : \"Not Found\" , \"detail\" : \"The requested resource could not be found.\" } ] }","title":"Example response"},{"location":"paths-and-operations/update/","text":"Update (PUT, PATCH) \u00b6 Full resource updates \u00b6 Requirement The operation must use PUT for a full resource update. Success operations must return a 200 status code. The operation must return a 404 status code if the resource can not be found. Guidance PUT should be idempotent, meaning that calling it several times should return the same result. The operation should return the resource inside a data object. The operation should return errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation). Example request \u00b6 PUT ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239877\" , \"prescriptionName\" : \"IBUPROFEN 200MG TAB\" , \"facilityName\" : \"DAYT30\" , \"stationNumber\" : \"990\" , \"orderedDate\" : \"2049-07-22T02:29:00Z\" , \"expirationDate\" : \"2050-07-22T02:49:00Z\" , \"dispensedDate\" : \"2049-07-23T011:17:00Z\" , \"quantity\" : 20 , \"isRefillable\" : false }, } } Example response \u00b6 200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239877\" , \"prescriptionName\" : \"IBUPROFEN 200MG TAB\" , \"facilityName\" : \"DAYT30\" , \"stationNumber\" : \"990\" , \"orderedDate\" : \"2049-07-22T02:29:00Z\" , \"expirationDate\" : \"2050-07-22T02:49:00Z\" , \"dispensedDate\" : \"2049-07-23T011:17:00Z\" , \"quantity\" : 20 , \"isRefillable\" : false }, } } Example error \u00b6 422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] } Partial resource updates \u00b6 Web frameworks differ on which HTTP verb to use for partial resource updates, with some defaulting to PUT for partials updates rather than the REST-prescribed PATCH . Providers should prefer PATCH , but this is not a strict requirement. Requirement On success, the operation must return a 200 status code. The operation must return a 404 status code if the resource can not be found. Guidance The operation should use PATCH for a partial resource update. With PUT or PATCH it should be idempotent, meaning that calling it more than once will not change the result. Only the fields being updated should be included in the request body. The operation should return the resource inside a data object. The operation should return errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation). Example request \u00b6 PATCH ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 2 3 4 5 6 7 8 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"isRefillable\" : true }, } } Example response \u00b6 200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239877\" , \"prescriptionName\" : \"IBUPROFEN 200MG TAB\" , \"facilityName\" : \"DAYT30\" , \"stationNumber\" : \"990\" , \"orderedDate\" : \"2049-07-22T02:29:00Z\" , \"expirationDate\" : \"2050-07-22T02:49:00Z\" , \"dispensedDate\" : \"2049-07-23T011:17:00Z\" , \"quantity\" : 20 , \"isRefillable\" : true }, } } Example error \u00b6 422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] }","title":"Update"},{"location":"paths-and-operations/update/#update-put-patch","text":"","title":"Update (PUT, PATCH)"},{"location":"paths-and-operations/update/#full-resource-updates","text":"Requirement The operation must use PUT for a full resource update. Success operations must return a 200 status code. The operation must return a 404 status code if the resource can not be found. Guidance PUT should be idempotent, meaning that calling it several times should return the same result. The operation should return the resource inside a data object. The operation should return errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation).","title":"Full resource updates"},{"location":"paths-and-operations/update/#example-request","text":"PUT ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239877\" , \"prescriptionName\" : \"IBUPROFEN 200MG TAB\" , \"facilityName\" : \"DAYT30\" , \"stationNumber\" : \"990\" , \"orderedDate\" : \"2049-07-22T02:29:00Z\" , \"expirationDate\" : \"2050-07-22T02:49:00Z\" , \"dispensedDate\" : \"2049-07-23T011:17:00Z\" , \"quantity\" : 20 , \"isRefillable\" : false }, } }","title":"Example request"},{"location":"paths-and-operations/update/#example-response","text":"200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239877\" , \"prescriptionName\" : \"IBUPROFEN 200MG TAB\" , \"facilityName\" : \"DAYT30\" , \"stationNumber\" : \"990\" , \"orderedDate\" : \"2049-07-22T02:29:00Z\" , \"expirationDate\" : \"2050-07-22T02:49:00Z\" , \"dispensedDate\" : \"2049-07-23T011:17:00Z\" , \"quantity\" : 20 , \"isRefillable\" : false }, } }","title":"Example response"},{"location":"paths-and-operations/update/#example-error","text":"422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] }","title":"Example error"},{"location":"paths-and-operations/update/#partial-resource-updates","text":"Web frameworks differ on which HTTP verb to use for partial resource updates, with some defaulting to PUT for partials updates rather than the REST-prescribed PATCH . Providers should prefer PATCH , but this is not a strict requirement. Requirement On success, the operation must return a 200 status code. The operation must return a 404 status code if the resource can not be found. Guidance The operation should use PATCH for a partial resource update. With PUT or PATCH it should be idempotent, meaning that calling it more than once will not change the result. Only the fields being updated should be included in the request body. The operation should return the resource inside a data object. The operation should return errors inside an errors object. The operation should return a 400 for syntax data errors (such as invalid JSON). The operation should return a 422 for semantic data errors (such as failing application validation).","title":"Partial resource updates"},{"location":"paths-and-operations/update/#example-request_1","text":"PATCH ../rx/v0/prescriptions/1c2dfaaa-4eb9-482e-86a9-4e7274975967 1 2 3 4 5 6 7 8 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"isRefillable\" : true }, } }","title":"Example request"},{"location":"paths-and-operations/update/#example-response_1","text":"200 OK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"data\" : { \"type\" : \"Prescription\" , \"attributes\" : { \"prescriptionNumber\" : \"1239877\" , \"prescriptionName\" : \"IBUPROFEN 200MG TAB\" , \"facilityName\" : \"DAYT30\" , \"stationNumber\" : \"990\" , \"orderedDate\" : \"2049-07-22T02:29:00Z\" , \"expirationDate\" : \"2050-07-22T02:49:00Z\" , \"dispensedDate\" : \"2049-07-23T011:17:00Z\" , \"quantity\" : 20 , \"isRefillable\" : true }, } }","title":"Example response"},{"location":"paths-and-operations/update/#example-error_1","text":"422 Unprocessable Entity 1 2 3 4 5 6 7 8 9 10 { \"errors\" : [ { \"status\" : \"422\" , \"source\" : { \"pointer\" : \"/data/attributes/isRefillable\" }, \"title\" : \"Invalid Attribute\" , \"detail\" : \"isRefillable must be a boolean value.\" } ] }","title":"Example error"},{"location":"security/","text":"Security \u00b6 Provider authentication and authorization \u00b6 Lighthouse can help protect access to your APIs with a layer of FedRAMP -approved authentication (AuthN) and authorization (AuthZ) using API keys or OAuth 2.0. Whether your API uses an API key or OAuth 2.0 integration pattern depends on the needs of your API, such as the type of users or data involved. APIs that involve user authentication, personally identifiable information (PII), protected health information (PHI), or scoped or time-limited access will use OAuth 2.0. Otherwise, your API will use an API key. The flowchart below can help you determine which one to use.","title":"Security"},{"location":"security/#security","text":"","title":"Security"},{"location":"security/#provider-authentication-and-authorization","text":"Lighthouse can help protect access to your APIs with a layer of FedRAMP -approved authentication (AuthN) and authorization (AuthZ) using API keys or OAuth 2.0. Whether your API uses an API key or OAuth 2.0 integration pattern depends on the needs of your API, such as the type of users or data involved. APIs that involve user authentication, personally identifiable information (PII), protected health information (PHI), or scoped or time-limited access will use OAuth 2.0. Otherwise, your API will use an API key. The flowchart below can help you determine which one to use.","title":"Provider authentication and authorization"},{"location":"security/api-key/","text":"API key \u00b6 APIs that don't involve user authentication, PII, or PHI can use API keys for access control. Otherwise, your API will use OAuth 2.0 . External consumers will register for access to an API and obtain an API key via the developer portal . API keys are passed in using a request header and validated at the gateway. An API will not receive a request through the gateway without having a valid API key. You can identify the consumer using the X-Consumer-Username header in the request. Requirement Lighthouse does not apply resource or role-based access control with API keys. Your API is responsible for any fine-grained authorization.","title":"API Key"},{"location":"security/api-key/#api-key","text":"APIs that don't involve user authentication, PII, or PHI can use API keys for access control. Otherwise, your API will use OAuth 2.0 . External consumers will register for access to an API and obtain an API key via the developer portal . API keys are passed in using a request header and validated at the gateway. An API will not receive a request through the gateway without having a valid API key. You can identify the consumer using the X-Consumer-Username header in the request. Requirement Lighthouse does not apply resource or role-based access control with API keys. Your API is responsible for any fine-grained authorization.","title":"API key"},{"location":"security/oauth/","text":"OAuth 2.0 \u00b6 OAuth 2.0 lets an API consumer get an access token on behalf of a user (through our authorization code flow or authorization code flow with proof key for code exchange) or system (through client credentials grant). The API will verify the access token and authorize the request. If your API will use OAuth 2.0, you need to provide the following as part of onboarding: Supported scopes Intended audience (for identity providers) Token profile (defaults are provided below, but Lighthouse can change these if you need) - Token lifespan (default is 1 hour for users, 5 minutes for systems) - Offline access using refresh tokens (default is enabled for users) - Refresh token lifespan (default is 7 days for users) Lighthouse uses this information to establish a dedicated OAuth server authorization for your API or set of related APIs and consumer documentation on the developer portal, if applicable. The OAuth URLs will typically mirror your service URLs and will follow this format: 1 https://sandbox-api.va.gov/oauth2/{service-name}/{system}/v1/* Lighthouse will give you: OAuth 2.0/OpenID Connect (OIDC) issuer metadata ( See an example of OIDC issuer metadata ), which: - Defines a valid token issuer - Defines the token signing keys - Acts as a quick-start guide for consumers using OAuth 2.0/OIDC libraries (more information on building OAuth 2.0/OIDC applications is available on the Lighthouse Authorization page) A token-validation key Consumers will register for access to your API and obtain OAuth credentials via the developer portal .","title":"OAuth 2.0"},{"location":"security/oauth/#oauth-20","text":"OAuth 2.0 lets an API consumer get an access token on behalf of a user (through our authorization code flow or authorization code flow with proof key for code exchange) or system (through client credentials grant). The API will verify the access token and authorize the request. If your API will use OAuth 2.0, you need to provide the following as part of onboarding: Supported scopes Intended audience (for identity providers) Token profile (defaults are provided below, but Lighthouse can change these if you need) - Token lifespan (default is 1 hour for users, 5 minutes for systems) - Offline access using refresh tokens (default is enabled for users) - Refresh token lifespan (default is 7 days for users) Lighthouse uses this information to establish a dedicated OAuth server authorization for your API or set of related APIs and consumer documentation on the developer portal, if applicable. The OAuth URLs will typically mirror your service URLs and will follow this format: 1 https://sandbox-api.va.gov/oauth2/{service-name}/{system}/v1/* Lighthouse will give you: OAuth 2.0/OpenID Connect (OIDC) issuer metadata ( See an example of OIDC issuer metadata ), which: - Defines a valid token issuer - Defines the token signing keys - Acts as a quick-start guide for consumers using OAuth 2.0/OIDC libraries (more information on building OAuth 2.0/OIDC applications is available on the Lighthouse Authorization page) A token-validation key Consumers will register for access to your API and obtain OAuth credentials via the developer portal .","title":"OAuth 2.0"},{"location":"security/oauth/identity-providers/","text":"Identity providers \u00b6 Lighthouse OAuth supports multiple identity providers to meet the needs of your API. Access token formats and structures will vary based on the identity provider. The flowchart below can help you determine which format or structure applies. External (ID.me, DSL, MHV, Login.gov) \u00b6 Lighthouse partners with multiple external identity providers to allow authentication of external users, such as Veterans. External users must be identity-proofed. They require multi-factor authentication (MFA). Shared test accounts are available in the sandbox environment. Learn more about test accounts . Access tokens issued for external users will be signed JSON Web Tokens (JWTs). Details on identifying the user context are in the section about Token Validation . Internal (IAM SSOi) \u00b6 Lighthouse partners with VA's identity and access management (IAM) system to allow authentication and single-sign-on of internal users such as VA employees and contractors. Internal users require a PIV card or Windows authentication to obtain an OAuth access token. Shared test accounts are available in the sandbox environment. Access them in the test persona manager through the VA network. Access tokens issued for internal users will be opaque tokens. For details on identifying the user context, see Token Validation . Info For internal users, Lighthouse performs only authentication. If needed, your API should implement any fine-grained authorization or role-based access control (RBAC). System-to-system \u00b6 Lighthouse allows systems to obtain an OAuth access token for interacting with an API outside of the context of a user. Systems will authenticate using client-owned, asymmetric, public/private keys for enhanced security. Learn more in private_key_jwt authentication . Access tokens issued for systems will be signed [JSON Web Tokens (JWTs). For details on identifying the consuming system, go to the section on Token Validation .","title":"Identity Providers"},{"location":"security/oauth/identity-providers/#identity-providers","text":"Lighthouse OAuth supports multiple identity providers to meet the needs of your API. Access token formats and structures will vary based on the identity provider. The flowchart below can help you determine which format or structure applies.","title":"Identity providers"},{"location":"security/oauth/identity-providers/#external-idme-dsl-mhv-logingov","text":"Lighthouse partners with multiple external identity providers to allow authentication of external users, such as Veterans. External users must be identity-proofed. They require multi-factor authentication (MFA). Shared test accounts are available in the sandbox environment. Learn more about test accounts . Access tokens issued for external users will be signed JSON Web Tokens (JWTs). Details on identifying the user context are in the section about Token Validation .","title":"External (ID.me, DSL, MHV, Login.gov)"},{"location":"security/oauth/identity-providers/#internal-iam-ssoi","text":"Lighthouse partners with VA's identity and access management (IAM) system to allow authentication and single-sign-on of internal users such as VA employees and contractors. Internal users require a PIV card or Windows authentication to obtain an OAuth access token. Shared test accounts are available in the sandbox environment. Access them in the test persona manager through the VA network. Access tokens issued for internal users will be opaque tokens. For details on identifying the user context, see Token Validation . Info For internal users, Lighthouse performs only authentication. If needed, your API should implement any fine-grained authorization or role-based access control (RBAC).","title":"Internal (IAM SSOi)"},{"location":"security/oauth/identity-providers/#system-to-system","text":"Lighthouse allows systems to obtain an OAuth access token for interacting with an API outside of the context of a user. Systems will authenticate using client-owned, asymmetric, public/private keys for enhanced security. Learn more in private_key_jwt authentication . Access tokens issued for systems will be signed [JSON Web Tokens (JWTs). For details on identifying the consuming system, go to the section on Token Validation .","title":"System-to-system"},{"location":"security/oauth/scopes/","text":"Scopes \u00b6 OAuth scopes limit a consumer's access to an API. You will need to define the set of scopes your API supports, including: The scope\u2019s name and display name A scope description Whether or not the scopes require user consent It is possible to grant consumers access to a subset of scopes, depending on their needs. Scopes can be as broad or granular as needed; for example, patient/Patient.write granting access to write/update any patient data versus patient/EmergencyContact.write granting access to write or update a patient's emergency contact only. You will need to validate that the access token has the scope(s) required for the requested resource. For more information, go to the Token Validation section. Scope name \u00b6 For the scope name, Lighthouse recommends one of the following naming conventions. Naming Convention Format Example SMART-on-FHIR style <patient:user:system>/<resource>.<read:write> patient/Observation.read Hierarchical style <api>.<resource>.<action> facilities.phone.manage Scope display name \u00b6 The scope display name will be shown to a user on a consent form. It should be written in plain language. For example, if your scope name is patient/AllergyIntolerance.read a good display name is: Allergies Scope description \u00b6 The scope description is displayed to a user as help-text on a consent form. It should be written in plain language. For example, if your scope is patient/AllergyIntolerance.read a good description is: A list of any substances to which you have a negative reaction. Examples include pollen, gluten, or bee stings. User consent for scopes \u00b6 Some users may be required to consent to scopes for the consuming application to access certain data. What we need from you is to know whether or not a user must consent to an application's request for this scope. 1 require consent: true","title":"Scopes"},{"location":"security/oauth/scopes/#scopes","text":"OAuth scopes limit a consumer's access to an API. You will need to define the set of scopes your API supports, including: The scope\u2019s name and display name A scope description Whether or not the scopes require user consent It is possible to grant consumers access to a subset of scopes, depending on their needs. Scopes can be as broad or granular as needed; for example, patient/Patient.write granting access to write/update any patient data versus patient/EmergencyContact.write granting access to write or update a patient's emergency contact only. You will need to validate that the access token has the scope(s) required for the requested resource. For more information, go to the Token Validation section.","title":"Scopes"},{"location":"security/oauth/scopes/#scope-name","text":"For the scope name, Lighthouse recommends one of the following naming conventions. Naming Convention Format Example SMART-on-FHIR style <patient:user:system>/<resource>.<read:write> patient/Observation.read Hierarchical style <api>.<resource>.<action> facilities.phone.manage","title":"Scope name"},{"location":"security/oauth/scopes/#scope-display-name","text":"The scope display name will be shown to a user on a consent form. It should be written in plain language. For example, if your scope name is patient/AllergyIntolerance.read a good display name is: Allergies","title":"Scope display name"},{"location":"security/oauth/scopes/#scope-description","text":"The scope description is displayed to a user as help-text on a consent form. It should be written in plain language. For example, if your scope is patient/AllergyIntolerance.read a good description is: A list of any substances to which you have a negative reaction. Examples include pollen, gluten, or bee stings.","title":"Scope description"},{"location":"security/oauth/scopes/#user-consent-for-scopes","text":"Some users may be required to consent to scopes for the consuming application to access certain data. What we need from you is to know whether or not a user must consent to an application's request for this scope. 1 require consent: true","title":"User consent for scopes"},{"location":"security/oauth/token-validation/","text":"Token validation \u00b6 Requirement APIs MUST confirm the presence and validity of the access token. Lighthouse does not perform token validation for OAuth 2.0 APIs at the gateway. The gateway acts as a pass-through. You are responsible for ensuring that requests contain a valid token and any further authorization decisions; however, Lighthouse provides a token validation service that we encourage you to use. The format and structure of the token may vary depending on the issuer and audience. Requests sent to your APIs should include an access token as a bearer authorization header for services that require authorization. 1 Authorization: Bearer xyz Token-validation service \u00b6 Lighthouse provides a RESTful service for API providers to validate a token. Using this service requires an API key, which will be issued during onboarding. If you use this service, you should implement a caching strategy for performance. This service abstracts away the token format, varying issuers, and signing keys and ensures consistent validation for all APIs. It verifies: Token was minted by a trusted Lighthouse issuer Token has not been modified (signature) Token is live nbf and not expired exp Audience matches expected value(s) The response will include the token's validity, claims, scopes, and more. The response is described in detail in the service's OpenAPI specification. Lighthouse provides a guided walk-through of the token-validation service. An example request and response for a patient\u2019s health API token is shown below. Info Request values such as aud and response values will vary for your API and use cases. Sample Request 1 2 3 4 5 6 7 curl \\ --request POST \\ --header \"apikey: $KEY \" \\ --header \"Authorization: Bearer $ACCESS_TOKEN \" \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --data-urlencode 'aud=https://sandbox-api.va.gov/services/fhir' \\ 'https://sandbox-api.va.gov/internal/auth/v2/validation' Sample Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"data\" : { \"id\" : \"AT.ixr9-_pfifmbktxnx1POTokNhLEDgUuyfA3gkt7zkIM.oars1eevwquopfhnn2p6\" , \"type\" : \"validated_token\" , \"attributes\" : { \"ver\" : 1 , \"jti\" : \"AT.ixr9-_pfifmbktxnx1POTokNhLEDgUuyfA3gkt7zkIM.oars1eevwquopfhnn2p6\" , \"iss\" : \"https://deptva-eval.okta.com/oauth2/default\" , \"aud\" : \"api://default\" , \"iat\" : 1617636934 , \"exp\" : 1617640534 , \"cid\" : \"0oa5l33ab7tj62Zpv2p7\" , \"uid\" : \"0oa5l33ab7tj62Zpv2p7\" , \"scp\" : [ \"offline_access\" , \"launch/patient\" , \"patient/Patient.read\" , \"openid\" , \"profile\" ], \"sub\" : \"b24346a788c04dfea5048d44ad071181\" , \"act\" : { \"icn\" : \"1013657145V762143\" , \"type\" : \"patient\" , }, \"launch\" : { \"patient\" : \"1013657145V762143\" } } } } Self-verification \u00b6 If the bearer token format is a signed JWT, you may opt to validate the token yourself. If you choose to do this, you should implement a key-caching strategy and are responsible for sufficient validation that the: Token was minted by a trusted Lighthouse issuer Token has not been modified (signature) Token is live (nbf) and not expired (exp) Audience matches expected value(s) The signing keys and expected issuer can be retrieved from the provided metadata.","title":"Token Validation"},{"location":"security/oauth/token-validation/#token-validation","text":"Requirement APIs MUST confirm the presence and validity of the access token. Lighthouse does not perform token validation for OAuth 2.0 APIs at the gateway. The gateway acts as a pass-through. You are responsible for ensuring that requests contain a valid token and any further authorization decisions; however, Lighthouse provides a token validation service that we encourage you to use. The format and structure of the token may vary depending on the issuer and audience. Requests sent to your APIs should include an access token as a bearer authorization header for services that require authorization. 1 Authorization: Bearer xyz","title":"Token validation"},{"location":"security/oauth/token-validation/#token-validation-service","text":"Lighthouse provides a RESTful service for API providers to validate a token. Using this service requires an API key, which will be issued during onboarding. If you use this service, you should implement a caching strategy for performance. This service abstracts away the token format, varying issuers, and signing keys and ensures consistent validation for all APIs. It verifies: Token was minted by a trusted Lighthouse issuer Token has not been modified (signature) Token is live nbf and not expired exp Audience matches expected value(s) The response will include the token's validity, claims, scopes, and more. The response is described in detail in the service's OpenAPI specification. Lighthouse provides a guided walk-through of the token-validation service. An example request and response for a patient\u2019s health API token is shown below. Info Request values such as aud and response values will vary for your API and use cases. Sample Request 1 2 3 4 5 6 7 curl \\ --request POST \\ --header \"apikey: $KEY \" \\ --header \"Authorization: Bearer $ACCESS_TOKEN \" \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --data-urlencode 'aud=https://sandbox-api.va.gov/services/fhir' \\ 'https://sandbox-api.va.gov/internal/auth/v2/validation' Sample Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { \"data\" : { \"id\" : \"AT.ixr9-_pfifmbktxnx1POTokNhLEDgUuyfA3gkt7zkIM.oars1eevwquopfhnn2p6\" , \"type\" : \"validated_token\" , \"attributes\" : { \"ver\" : 1 , \"jti\" : \"AT.ixr9-_pfifmbktxnx1POTokNhLEDgUuyfA3gkt7zkIM.oars1eevwquopfhnn2p6\" , \"iss\" : \"https://deptva-eval.okta.com/oauth2/default\" , \"aud\" : \"api://default\" , \"iat\" : 1617636934 , \"exp\" : 1617640534 , \"cid\" : \"0oa5l33ab7tj62Zpv2p7\" , \"uid\" : \"0oa5l33ab7tj62Zpv2p7\" , \"scp\" : [ \"offline_access\" , \"launch/patient\" , \"patient/Patient.read\" , \"openid\" , \"profile\" ], \"sub\" : \"b24346a788c04dfea5048d44ad071181\" , \"act\" : { \"icn\" : \"1013657145V762143\" , \"type\" : \"patient\" , }, \"launch\" : { \"patient\" : \"1013657145V762143\" } } } }","title":"Token-validation service"},{"location":"security/oauth/token-validation/#self-verification","text":"If the bearer token format is a signed JWT, you may opt to validate the token yourself. If you choose to do this, you should implement a key-caching strategy and are responsible for sufficient validation that the: Token was minted by a trusted Lighthouse issuer Token has not been modified (signature) Token is live (nbf) and not expired (exp) Audience matches expected value(s) The signing keys and expected issuer can be retrieved from the provided metadata.","title":"Self-verification"}]}